{"./":{"url":"./","title":"实验简介","keywords":"","body":"rCore 教学实验（开发中） 本教学仓库是继 rCore_tutorial 后重构的版本。 仓库目录 docs/：教学实验指导分实验内容和开发规范 notes/：开题报告和若干讨论 os/：操作系统代码 SUMMARY.md：GitBook 目录页 book.json：GitBook 配置文件 rust-toolchain：限定 Rust 工具链版本 实验指导 基于 GitBook，目前\b已经部署到了 GitHub Pages 上面。 本地使用方法 npm install -g gitbook-cli gitbook install gitbook serve 代码 操作系统代码 基于 cargo 项目，进入 os 目录通过相关命令可以运行： cd os # 编译并运行 make run # 根据代码注释生成文档 cargo doc 参考和感谢 本文档和代码大量参考了： rCore_tutorial 使用Rust编写操作系统 在此对仓库的开发和维护者表示感谢，同时也感谢很多在本项目开发中一起讨论和勘误的老师和同学们。 "},"docs/format/partition.html":{"url":"docs/format/partition.html","title":"文档代码划分","keywords":"","body":"文档代码划分 文档和代码功能划分和注意事项 文档专注于 OS 的原理和同时涉及 OS 和 Rust 特性的 Rust 语言特性，不会花篇幅来讲解 Rust 语言本身； 文档中引用的代码和代码目录中代码保持一致； 代码中书写的注释专注于功能性，不会有流程性和原理性的介绍； 文档应有全面的包括流程性、原理性和功能性的介绍。 "},"docs/format/doc.html":{"url":"docs/format/doc.html","title":"文档格式规范","keywords":"","body":"文档规范 一些标准的架构、软件名词写法 语言相关 Rust C C++ 教程 rCore-Tutorial 操作系统相关 uCore rCore Linux macOS Windows Ubuntu 操作系统技术相关 物理页（而不是物理页帧） 虚拟页（而不是物理页帧） 架构相关 x86_64 RISC-V 64 其他一些名词 ABI GitHub Rust 相关 rustup cargo rustc 其他软件 QEMU Homebrew 书写格式 在数字、英文、独立的标点或记号两侧的中文之间要加空格，如： 安装 QEMU 分为 2 个部分 命令、宏名、寄存器、类型名、函数名、变量名、行间输出、编译选项、路径和文件名需要使用 记号 寄存器 a0 这样的也需要使用 记号，而不是 a0a_0a​0​​，这是为了和 sepc 统一 行内命令或运行输出引用使用 `` 记号，并在两侧加入空格，如： cargo run 出现 ERROR: pkg-config binary 'pkg-config' not found 时 行间命令使用 ``` 记号并加入语言记号： 命令使用 bash 记号 Rust 语言使用 rust 记号 cargo 的配置使用 toml 记号 如何命令只是命令，则不需要 $ 记号（方便同学复制），如：echo \"Hello, world.\" 如果在展示一个命令带来的输出效果，需要加入 $ 记号表示一个命令的开始，如：$ echo \"Hello, world.\" Hello, world. 粗体使用 ** 粗体 ** 记号 一些重要的概念最好进行加粗 斜体使用 * 斜体 * 记号，而不要混合使用 _ Italic _ 记号 在正式的段落中要加入标点符号，在 - 记号开始的列表中的单独名词表项不加入标点符号（但是如果是段落需要加），如： 操作系统有（名词罗列）： macOS Windows 我们需要（连贯段落）： 先打开 QEMU； 再关闭 QEMU。 在 / 记号两侧添加空格，如： Linux / Windows WSL 中文名词的英文解释多用大写，如： 裸机（Bare Metal） sepc （Supervisor Exception Program Counter） 只要是主体是中文的段落，括号统一使用中文括号（），如果主体是英文则使用英文括号 () 值得注意的是中文括号两侧本来就会又留白，这里不会在括号两侧加入空格 英文空格两侧最好加上空格 在文档中引用成段的代码时，需要填写上文件的路径，如： os/src/sbi.rs /// 向控制台输出一个字符 /// /// 需要注意我们不能直接使用 Rust 中的 char 类型 pub fn console_putchar(c: usize) { sbi_call(SBI_CONSOLE_PUTCHAR, c, 0, 0); } 在使用伪代码时，不使用 $ % 等符号描述寄存器，使用 := 表示赋值，例如 pc := sepc 代码过长或会让文档显得很长时，需要进行折叠 小节格式 章节的标题为使用 # 一级标题，后面的子标题依次加级别 小节的标题统一使用 ## 二级标题，后面的子标题依次加级别 "},"docs/format/code.html":{"url":"docs/format/code.html","title":"代码格式规范","keywords":"","body":"代码规范 代码风格 以 cargo 输出没有 Warning 为准 可以通过 cargo fmt 来自动规范代码 注释规范 用 //! 注释外层内容，例如在文件开始注释整个模块 用 /// 为函数添加 doc 注释，其内部使用 markdown 语法 可以使用 markdown 格式的链接，链接内容使用 rust 可以直接链上，例如 /// 样例注释 /// [`link`]: crate::xxx::xxx fn some_func() {} 对于地址 literal，使用小写，使用 _ 每隔四位进行标记，例如 0x8000_0000 0xffff_ffff_c000_0000 实现一个 trait 时，doc 是可选的，而如果有，应当写在 impl 上面，而不是具体的方法上面 ```rust /// doc here (optional) impl Default for Type { /// not here fn default() -> Self { ... } } 参考 https://doc.rust-lang.org/1.26.2/book/first-edition/comments.html https://doc.rust-lang.org/1.26.2/book/second-edition/ch14-02-publishing-to-crates-io.html "},"docs/pre-lab/rust.html":{"url":"docs/pre-lab/rust.html","title":"Rust 基础介绍","keywords":"","body":"Rust 基础介绍 "},"docs/pre-lab/os.html":{"url":"docs/pre-lab/os.html","title":"操作系统背景知识","keywords":"","body":"操作系统背景知识 "},"docs/pre-lab/env.html":{"url":"docs/pre-lab/env.html","title":"环境部署","keywords":"","body":"环境部署 在开展实验之前，我们需要根据不同的平台提前安装相关依赖的软件包，具体需要的软件包如下： Rust 工具链 Rust 版本管理工具：rustup Rust 软件包管理工具：cargo Rust 编译器：rustc 等等 虚拟机软件：QEMU （版本至少支持 RISC-V 64） 具体安装的方法在不同平台上安装方式类似，但也有细微差别，后面会有具体说明。 安装 QEMU 根据不同平台，我们分为下面 2 个部分来介绍。 macOS 在 macOS 中，我们可以直接打开命令行用 Homebrew 软件包管理器来安装最新版 QEMU 和其依赖： brew install qemu Linux / Windows WSL 在 Linux 中，由于很多软件包管理器的默认软件源中包含的 QEMU 版本过低，这里推荐的方式是我们自己手动从源码编译安装： # 下载源码包 （如果下载速度过慢可以把地址替换为我们提供的地址：TODO） wget https://download.qemu.org/qemu-4.2.0.tar.xz # 解压 tar xvJf qemu-4.2.0.tar.xz # 编译安装并配置 RISC-V 支持 cd qemu-4.2.0 ./configure --target-list=riscv32-softmmu,riscv64-softmmu make -j$(nproc) sudo make install 如果在运行 configure 时遇到软件包依赖的问题（以 Ubuntu 系统举例）： 出现 ERROR: pkg-config binary 'pkg-config' not found 时，可以通过 sudo apt-get install pkg-config 安装； 出现 ERROR: glib-2.48 gthread-2.0 is required to compile QEMU 时，可以通过 sudo apt-get install libglib2.0-dev 安装； 出现 ERROR: pixman >= 0.21.8 not present 时，可以通过 sudo apt-get install libpixman-1-dev 安装。 如果有其他问题，请针对不同操作系统在软件包管理器中查找并安装依赖。 当然如果你可以找到包含较新版本的 QEMU 的软件包源，也可以通过软件包管理器直接安装： # Ubuntu / Debian / Windows WSL sudo apt-get install qemu # CentOS / Fedora / RedHat / SUSE sudo yum install qemu 完成后 安装完成后可以用 qemu-system-riscv64 --version 命令检查是否成功安装我们需要的 RISC-V 64 虚拟器。 安装 Rust 工具链 首先安装 Rust 版本管理器 rustup 和 Rust 包管理器 cargo，这里我们用官方的安装脚本来安装： curl https://sh.rustup.rs -sSf | sh 如果通过官方的脚本下载失败了，可以在浏览器的地址栏中输入 https://sh.rustup.rs 来下载脚本，在本地运行即可。 如果官方的脚本在运行时出现了网络速度较慢的问题，可选地可以通过修改 rustup 的镜像地址（修改为中国科学技术大学的镜像服务器）来加速： export RUSTUP_DIST_SERVER=https://mirrors.ustc.edu.cn/rust-static export RUSTUP_UPDATE_ROOT=https://mirrors.ustc.edu.cn/rust-static/rustup curl https://sh.rustup.rs -sSf | sh 或者也可以通过在运行前设置命令行中的科学上网代理来实现： # e.g. Shadowsocks 代理 export https_proxy=http://127.0.0.1:1080 export http_proxy=http://127.0.0.1:1080 export ftp_proxy=http://127.0.0.1:1080 安装完成后，最好我们也可以把软件包管理器 cargo 所用的软件包镜像地址 crates.io 也换成中国科学技术大学的镜像服务器来加速。我们打开（如果没有就新建）~/.cargo/config 文件，并把内容修改为： [source.crates-io] registry = \"https://github.com/rust-lang/crates.io-index\" replace-with = 'ustc' [source.ustc] registry = \"git://mirrors.ustc.edu.cn/crates.io-index\" 安装完成后 在相关软件包安装完成之后，只需要下面的命令，就可以把整个教程完成之后的 rCore 系统在你的系统上运行起来： # 克隆仓库并编译运行 git clone TODO cd rCore-Tutorial git checkout master # 编译运行 make run 如果一切正常，则 QEMU 模拟的 RISC-V 64 处理器将输出 TODO 需要说明的是，Rust 包含 stable、beta 和 nightly 三个版本。默认情况下我们安装的是 stable 稳定版。由于在编写操作系统时需要使用 Rust 的一些不稳定的实验功能，因此我们使用 nightly 每日构建版。 但是，由于官方不保证 nightly 版本的 ABI 稳定性，也就意味着今天写的代码用未来的 nightly 可能无法编译通过，因此一般在使用 nightly 时应该锁定一个日期。 所以我们的工作目录下会有一个名为 rust-toolchain 的文件（无后缀名），在其中有所需的工具链版本： nightly-2020-03-06 在第一次编译项目时，rustup 会自动去下载对应版本的工具链。今后所有在这个目录或其子目录下使用 Rust 时都会自动切换到这个版本的工具链。随着日后的更新，后面的日期可能会变化，请以 GitHub 仓库上的版本为准。 "},"docs/lab-0/guide/intro.html":{"url":"docs/lab-0/guide/intro.html","title":"摘要","keywords":"","body":"实验指导零 实验概要 这一章的实验指导中，你将会学到： 使用 Rust 包管理器 cargo 创建一个 Rust 项目 移除 Rust 程序对操作系统的依赖，构建一个独立化可执行的程序 我们将程序的目标平台设置为 RISC-V，这样我们的代码将可以在 RISC-V 指令集的裸机（Bare Metal）上执行 Rust 代码 生成内核镜像、调整代码的内存布局并在 QEMU 模拟器中启动 封装如输出、关机等一些 SBI 的接口，方便后续开发 实验说明 实验指导的部分只包含如何一步步构建我们的目标，并不是练习题。如果你没有兴趣，你不需要完整跟着整个指导去动手做这件事情。但是也许你需要完整的阅读，这将对构建完整的操作系统概念和做练习题有很大帮助。 我们也提供了本章结束后完整的代码实现，你的练习题只需要基于我们给出的版本上增量实现即可。 "},"docs/lab-0/guide/part-1.html":{"url":"docs/lab-0/guide/part-1.html","title":"创建项目","keywords":"","body":"创建 Rust 项目 创建项目 我们首先创建一个整个项目的目录，并在工作目录中首先创建一个名为 rust-toolchain 的文件，并在其中写入所需要的工具链版本： rust-toolchain nightly-2020-03-06 之后在目录内部使用 cargo new 命令在我们的项目目录内创建一个新的 Rust 项目 os，命令如下： cargo new os 这里我们把项目命名为 os。同时，cargo 默认为我们添加了 --bin 选项，说明我们将要创建一个可执行文件而非一个库。 目录结构 创建完成后，整个项目的目录结构如下： Project 项目目录 ├── rust-toolchain Rust 工具链版本 └── os ├── Cargo.toml 项目配置文件 └── src 源代码路径 └── main.rs 源程序 构建和运行 接下来我们进入 os 文件夹，并尝试构建、运行项目： 运行输出 $ cargo run ... Hello, world! 打开 os/src/main.rs 发现里面确实只是输出了一行 Hello, world!。这个应用可以正常运行，但是即使只是这么一个简单的功能，也离不开所在操作系统的帮助。我们既然要写一个新的操作系统，就不能依赖于任何已有操作系统，接下来我们尝试移除该项目对于操作系统的依赖。 "},"docs/lab-0/guide/part-2.html":{"url":"docs/lab-0/guide/part-2.html","title":"移除标准库依赖","keywords":"","body":"移除标准库依赖 禁用标准库 项目默认是链接 Rust 标准库 std 的，它依赖于操作系统，因此我们需要显式通过 #![no_std] 将其禁用： os/src/main.rs //! # 全局属性 //! - `#![no_std]` //! 禁用标准库 #![no_std] fn main() { println!(\"Hello, world!\"); } 我们使用 cargo build 构建项目，会出现下面的错误： 运行输出 error: cannot find macro `println` in this scope --> src/main.rs:3:5 | 7 | println!(\"Hello, world!\"); | ^^^^^^^ error: `#[panic_handler]` function required, but not found error: language item required, but not found: `eh_personality` 接下来，我们依次解决这些问题。 宏 println! 第一个错误是说 println! 宏未找到，实际上这个宏属于 Rust 标准库 std，它会依赖操作系统标准输出等一系列功能。由于它被我们禁用了当然就找不到了。我们暂时将该输出语句删除，之后给出不依赖操作系统的实现。 panic 处理函数 第二个错误是说需要一个函数作为 panic_handler ，这个函数负责在程序发生 panic 时调用。它默认使用标准库 std 中实现的函数并依赖于操作系统特殊的文件描述符，由于我们禁用了标准库，因此只能自己实现它： os/src/main.rs use core::panic::PanicInfo; /// 当 panic 发生时会调用该函数 /// 我们暂时将它的实现为一个死循环 #[panic_handler] fn panic(_info: &PanicInfo) -> ! { loop {} } [info] Rust Panic Panic 在 Rust 中表明程序遇到了错误，需要被迫停止运行或者通过捕获的机制来处理。 类型为 PanicInfo 的参数包含了 panic 发生的文件名、代码行数和可选的错误信息。这个函数从不返回，所以他被标记为发散函数（Diverging Function）。发散函数的返回类型称作 Never 类型（\"never\" type），记为 !。对这个函数，我们目前能做的很少，所以我们只需编写一个死循环 loop {}。 这里我们用到了核心库 core，与标准库 std 不同，这个库不需要操作系统的支持，下面我们还会与它打交道。 eh_personality 语义项 第三个错误提到了语义项（Language Item） ，它是编译器内部所需的特殊函数或类型。刚才的 panic_handler 也是一个语义项，我们要用它告诉编译器当程序发生 panic 之后如何处理。 而这个错误相关语义项 eh_personality ，其中 eh 是 Exception Handling 的缩写，它是一个标记某函数用来实现堆栈展开处理功能的语义项。这个语义项也与 panic 有关。 [info] 堆栈展开 (Stack Unwinding) 通常当程序出现了异常时，从异常点开始会沿着 caller 调用栈一层一层回溯，直到找到某个函数能够捕获这个异常或终止程序。这个过程称为堆栈展开。 当程序出现异常时，我们需要沿着调用栈一层层回溯上去回收每个 caller 中定义的局部变量（这里的回收包括 C++ 的 RAII 的析构以及 Rust 的 drop 等）避免造成捕获异常并恢复后的内存溢出。 而在 Rust 中，panic 证明程序出现了错误，我们则会对于每个 caller 函数调用依次这个被标记为堆栈展开处理函数的函数进行清理。 这个处理函数是一个依赖于操作系统的复杂过程，在标准库中实现。但是我们禁用了标准库使得编译器找不到该过程的实现函数了。 简单起见，我们这里不会进一步捕获异常也不需要清理现场，我们设置为直接退出程序即可。这样堆栈展开处理函数不会被调用，编译器也就不会去寻找它的实现了。 因此，我们在项目配置文件中直接将 dev 配置和 release 配置的 panic 的处理策略设为直接终止，也就是直接调用我们的 panic_handler 而不是先进行堆栈展开等处理再调用。 os/Cargo.toml ... # panic 时直接终止，因为我们没有实现堆栈展开的功能 [profile.dev] panic = \"abort\" [profile.release] panic = \"abort\" 此时，我们 cargo build ，但是又出现了新的错误，我们将在后面的部分解决： 运行输出 error: requires `start` lang_item "},"docs/lab-0/guide/part-3.html":{"url":"docs/lab-0/guide/part-3.html","title":"移除运行时环境依赖","keywords":"","body":"移除运行时环境依赖 运行时系统 对于大多数语言，他们都使用了运行时系统（Runtime System），这可能导致 main 函数并不是实际执行的第一个函数。 以 Rust 语言为例，一个典型的链接了标准库的 Rust 程序会首先跳转到 C 语言运行时环境中的 crt0（C Runtime Zero）进入 C 语言运行时环境设置 C 程序运行所需要的环境（如创建堆栈或设置寄存器参数等）。 然后 C 语言运行时环境会跳转到 Rust 运行时环境的入口点（Entry Point）进入 Rust 运行时入口函数继续设置 Rust 运行环境，而这个 Rust 的运行时入口点就是被 start 语义项标记的。Rust 运行时环境的入口点结束之后才会调用 main 函数进入主程序。 C 语言运行时环境和 Rust 运行时环境都需要标准库支持，我们的程序无法访问。如果覆盖了 start 语义项，仍然需要 crt0，并不能解决问题。所以需要重写覆盖整个 crt0 入口点： os/src/main.rs //! # 全局属性 //! - `#![no_std]` //! 禁用标准库 #![no_std] //! //! - `#![no_main]` //! 不使用 `main` 函数等全部 Rust-level 入口点来作为程序入口 #![no_main] use core::panic::PanicInfo; /// 当 panic 发生时会调用该函数 /// 我们暂时将它的实现为一个死循环 #[panic_handler] fn panic(_info: &PanicInfo) -> ! { loop {} } /// 覆盖 crt0 中的 _start 函数 /// 我们暂时将它的实现为一个死循环 #[no_mangle] pub extern \"C\" fn _start() -> ! { loop {} } 我们加上 #![no_main] 告诉编译器我们不用常规的入口点。 同时我们实现一个 _start 函数来代替 crt0，并加上 #[no_mangle] 告诉编译器对于此函数禁用编译期间的名称重整（Name Mangling），即确保编译器生成一个名为 _start 的函数，而非为了实现函数重载等而生成的形如 _ZN3blog_os4_start7hb173fedf945531caE 散列化后的函数名。由于 _start 是大多数系统的默认入口点名字，所以我们要确保它不会发生变化。 接着，我们使用 extern \"C\" 描述 _start 函数，这是 Rust 中的 FFI （Foreign Function Interface, 语言交互接口）语法，表示此函数是一个 C 函数而非 Rust 函数。由于 _start 是作为 C 语言运行时的入口点，看起来合情合理。 由于程序会一直停在 crt0 的入口点，我们可以移除没用的 main 函数。 链接错误 再次 cargo build ，我们会看到一大段链接错误。 链接器（Linker）是一个程序，它将生成的目标文件组合为一个可执行文件。不同的操作系统如 Windows、macOS 或 Linux，规定了不同的可执行文件格式，因此也各有自己的链接器，抛出不同的错误；但这些错误的根本原因还是相同的：链接器的默认配置假定程序依赖于 C 语言的运行时环境，但我们的程序并不依赖于它。 为了解决这个错误，我们需要告诉链接器，它不应该包含 C 语言运行时环境。我们可以选择提供特定的链接器参数（Linker Argument），也可以选择编译为裸机目标（Bare Metal Target），我们将沿着后者的思路在后面解决这个问题，即直接编译为裸机目标不链接任何运行时环境。 "},"docs/lab-0/guide/part-4.html":{"url":"docs/lab-0/guide/part-4.html","title":"编译为裸机目标","keywords":"","body":"编译为裸机目标 在默认情况下，Rust 尝试适配当前的系统环境，编译可执行程序。举个例子，如果你使用 x86_64 平台的 Windows 系统，Rust 将尝试编译一个扩展名为 .exe 的 Windows 可执行程序，并使用 x86_64 指令集。这个环境又被称作为你的宿主系统（Host System）。 为了描述不同的环境，Rust 使用一个称为目标三元组（Target Triple）的字符串 ---。要查看当前系统的目标三元组，我们可以运行 rustc --version --verbose： 运行输出 rustc 1.35.0-nightly (474e7a648 2019-04-07) binary: rustc commit-hash: 474e7a6486758ea6fc761893b1a49cd9076fb0ab commit-date: 2019-04-07 host: x86_64-unknown-linux-gnu release: 1.35.0-nightly LLVM version: 8.0 上面这段输出来自一个 x86_64 平台下的 Linux 系统。我们能看到，host 字段的值为三元组 x86_64-unknown-linux-gnu，它包含了 CPU 架构 x86_64、供应商 unknown、操作系统 linux 和二进制接口 gnu。 Rust 编译器尝试为当前系统的三元组编译，并假定底层有一个类似于 Windows 或 Linux 的操作系统提供 C 语言运行环境，然而这将导致链接器错误。所以，为了避免这个错误，我们可以另选一个底层没有操作系统的运行环境。 这样的运行环境被称作裸机环境，例如目标三元组 riscv64imac-unknown-none-elf 描述了一个 RISC-V 64 位指令集的系统。我们暂时不需要了解它的细节，只需要知道这个环境底层没有操作系统，这是由三元组中的 none 描述的。要为这个目标编译，我们需要使用 rustup 添加它： 运行命令 rustup target add riscv64imac-unknown-none-elf 这行命令将为目标下载一个标准库和 core 库。这之后，我们就能为这个目标成功构建独立式可执行程序了： 运行命令 cargo build --target riscv64imac-unknown-none-elf 编译出的结果被放在了 os/target/riscv64imac-unknown-none-elf/debug 文件夹中。可以看到其中有一个名为 os 的可执行文件。不过由于它的目标平台是 RISC-V 64，我们暂时还不能通过我们的开发环境执行它。 由于我们之后都会使用 RISC-V 作为编译目标，为了避免每次都要加 --target 参数，我们可以使用 cargo 配置文件为项目配置默认的编译选项。 在 os 文件夹中创建一个 .cargo 文件夹，并在其中创建一个名为 config 的文件，在其中填入以下内容： os/.cargo/config # 编译的目标平台 [build] target = \"riscv64imac-unknown-none-elf\" 这指定了此项目编译时默认的目标。以后我们就可以直接使用 cargo build 来编译了。 至此，我们完成了在 RISC-V 64 位平台的二进制程序编译，后面我们将通过布局和代码的简单调整实现一个最简单的内核。 "},"docs/lab-0/guide/part-5.html":{"url":"docs/lab-0/guide/part-5.html","title":"生成内核镜像","keywords":"","body":"生成内核镜像 安装 binutils 工具集 为了查看和分析生成的可执行文件，我们首先需要安装一套名为 binutils 的命令行工具集，其中包含了 objdump 和 objcopy 等常用工具。 Rust 社区提供了一个 cargo-binutils 项目，可以帮助我们方便地调用 Rust 内置的 LLVM binutils。我们用以下命令安装它： 运行命令 cargo install cargo-binutils rustup component add llvm-tools-preview 之后尝试使用 rust-objdump --version 命令看看是否安装成功。 [info] 其它选择：GNU 工具链 除了内置的 LLVM 工具链以外，我们也可以使用 GNU 工具链，其中还包含了 GCC 等 C 语言工具链。 我们可以在 https://www.sifive.com/boards#software 上去下载最新的适合自己操作系统的预编译版本。 查看生成的可执行文件 我们编译之后的产物为 os/target/riscv64imac-unknown-none-elf/debug/os，让我们先看看它的文件类型： 运行输出 $ file target/riscv64imac-unknown-none-elf/debug/os target/riscv64imac-unknown-none-elf/debug/os: ELF 64-bit LSB executable, UCB RISC-V, version 1 (SYSV), statically linked, with debug_info, not stripped 从中，我们可以看出它是一个 64 位的 elf 格式的可执行文件，架构是 RISC-V；链接方式为静态链接；not stripped 指的是里面符号表的信息未被剔除，而这些信息在调试程序时会用到，程序正常执行时通常不会使用。 接下来使用刚刚安装的工具链中的 rust-objdump 工具看看它的具体信息： 运行输出 $ rust-objdump target/riscv64imac-unknown-none-elf/debug/os -x --arch-name=riscv64 target/riscv64imac-unknown-none-elf/debug/os: file format ELF64-riscv architecture: riscv64 start address: 0x0000000000011000 Sections: Idx Name Size VMA Type 0 00000000 0000000000000000 1 .text 0000000c 0000000000011000 TEXT 2 .debug_str 000004f6 0000000000000000 3 .debug_abbrev 0000010e 0000000000000000 4 .debug_info 00000633 0000000000000000 5 .debug_aranges 00000040 0000000000000000 6 .debug_ranges 00000030 0000000000000000 7 .debug_macinfo 00000001 0000000000000000 8 .debug_pubnames 000000ce 0000000000000000 9 .debug_pubtypes 000003a2 0000000000000000 10 .debug_frame 00000068 0000000000000000 11 .debug_line 00000059 0000000000000000 12 .comment 00000012 0000000000000000 13 .symtab 00000108 0000000000000000 14 .shstrtab 000000b4 0000000000000000 15 .strtab 0000002d 0000000000000000 SYMBOL TABLE: 0000000000000000 l df *ABS* 00000000 3k1zkxjipadm3tm5 0000000000000000 .debug_frame 00000000 0000000000011000 .text 00000000 0000000000011000 .text 00000000 0000000000011000 .text 00000000 000000000001100c .text 00000000 0000000000000000 .debug_ranges 00000000 0000000000000000 .debug_info 00000000 0000000000000000 .debug_line 00000000 .Lline_table_start0 0000000000011000 g F .text 0000000c _start Program Header: PHDR off 0x0000000000000040 vaddr 0x0000000000010040 paddr 0x0000000000010040 align 2**3 filesz 0x00000000000000e0 memsz 0x00000000000000e0 flags r-- LOAD off 0x0000000000000000 vaddr 0x0000000000010000 paddr 0x0000000000010000 align 2**12 filesz 0x0000000000000120 memsz 0x0000000000000120 flags r-- LOAD off 0x0000000000001000 vaddr 0x0000000000011000 paddr 0x0000000000011000 align 2**12 filesz 0x0000000000001000 memsz 0x0000000000001000 flags r-x STACK off 0x0000000000000000 vaddr 0x0000000000000000 paddr 0x0000000000000000 align 2**64 filesz 0x0000000000000000 memsz 0x0000000000000000 flags rw- Dynamic Section: 我们按顺序逐个查看： start address：程序的入口地址 Sections：从这里我们可以看到程序各段的各种信息。后面以 debug 开头的段是调试信息 SYMBOL TABLE：符号表，从中我们可以看到程序中所有符号的地址。例如 _start 函数就位于入口地址上 Program Header：程序加载时所需的段信息 其中的 off 是它在文件中的位置，vaddr 和 paddr 是要加载到的虚拟地址和物理地址，align 规定了地址的对齐，filesz 和 memsz 分别表示它在文件和内存中的大小，flags 描述了相关权限（r 表示可读，w 表示可写，x 表示可执行） 在这里我们使用的是 -x 来查看程序的元信息，下面我们用 -d 来对代码进行反汇编： 运行输出 $ rust-objdump target/riscv64imac-unknown-none-elf/debug/os -d --arch-name=riscv64 target/riscv64imac-unknown-none-elf/debug/os: file format ELF64-riscv Disassembly of section .text: 0000000000011000 _start: 11000: 41 11 addi sp, sp, -16 11002: 06 e4 sd ra, 8(sp) 11004: 22 e0 sd s0, 0(sp) 11006: 00 08 addi s0, sp, 16 11008: 09 a0 j 2 1100a: 01 a0 j 0 可以看到其中只有一个 _start 函数，里面什么都不做，就一个死循环。 生成镜像 我们之前生成的 elf 格式可执行文件有以下特点： 含有冗余的调试信息，使得程序体积较大 需要对 Program Header 部分进行手动解析才能知道各段的信息，而这需要我们了解 Program Header 的二进制格式，并以字节为单位进行解析 由于我们目前没有调试的手段，不需要调试信息；同时也不会解析 elf 格式文件，所以我们可以使用工具 rust-objcopy 从 elf 格式可执行文件生成内核镜像： rust-objcopy target/riscv64imac-unknown-none-elf/debug/os --strip-all -O binary target/riscv64imac-unknown-none-elf/debug/kernel.bin 这里 --strip-all 表明丢弃所有符号表及调试信息，-O binary 表示输出为二进制文件。 至此，我们编译并生成了内核镜像 kernel.bin 文件。接下来，我们将使用 QEMU 模拟器真正将我们的内核镜像跑起来。不过在此之前还需要完成两个工作：调整内存布局和重写入口函数。 "},"docs/lab-0/guide/part-6.html":{"url":"docs/lab-0/guide/part-6.html","title":"调整内存布局","keywords":"","body":"调整内存布局 上一节中我们看到，编译出的程序默认被放到了从 0x11000 开始的位置上： 运行输出 start address: 0x0000000000011000 ... Program Header: PHDR off 0x0000000000000040 vaddr 0x0000000000010040 ... LOAD off 0x0000000000000000 vaddr 0x0000000000010000 ... LOAD off 0x0000000000001000 vaddr 0x0000000000011000 ... STACK off 0x0000000000000000 vaddr 0x0000000000000000 ... 这是因为对于普通用户程序来说，数据是放在低地址空间上的。 但是对于 OS 内核，它一般都在高地址空间上。并且在 RISC-V 中，内存的物理地址也是从 0x80000000 开始的。因此接下来我们需要调整程序的内存布局，改变它的链接地址。 [info] 程序的内存布局 一般来说，一个程序按照功能不同会分为下面这些段： .text 段：代码段，存放汇编代码 .rodata 段：只读数据段，顾名思义里面存放只读数据，通常是程序中的常量 .data 段：存放被初始化的可读写数据，通常保存程序中的全局变量 .bss 段：存放被初始化为 0 的可读写数据，与 .data 段的不同之处在于我们知道它要被初始化为 0，因此在可执行文件中只需记录这个段的大小以及所在位置即可，而不用记录里面的数据，也不会实际占用二进制文件的空间 Stack：栈，用来存储程序运行过程中的局部变量，以及负责函数调用时的各种机制。它从高地址向低地址增长 Heap：堆，用来支持程序运行过程中内存的动态分配，比如说你要读进来一个字符串，在你写程序的时候你也不知道它的长度究竟为多少，于是你只能在运行过程中，知道了字符串的长度之后，再在堆中给这个字符串分配内存 内存布局，也就是指这些段各自所放的位置。一种典型的内存布局如下： 编写链接脚本 我们使用链接脚本（Linker Script）来指定程序的内存布局。创建文件 os/src/linker/linker.ld： os/src/linker/linker.ld /* Linker Script 语法可以参见：http://www.scoberlin.de/content/media/http/informatik/gcc_docs/ld_3.html */ /* 目标架构 */ OUTPUT_ARCH(riscv) /* 执行入口 */ ENTRY(_start) /* 数据存放起始地址 */ BASE_ADDRESS = 0x80200000; SECTIONS { /* . 表示当前地址（location counter） */ . = BASE_ADDRESS; /* start 符号表示全部的开始位置 */ kernel_start = .; text_start = .; /* .text 字段 */ .text : { /* 把 entry 函数放在最前面 */ *(.text.entry) /* 要链接的文件的 .text 字段集中放在这里 */ *(.text .text.*) } rodata_start = .; /* .rodata 字段 */ .rodata : { /* 要链接的文件的 .rodata 字段集中放在这里 */ *(.rodata .rodata.*) } data_start = .; /* .data 字段 */ .data : { /* 要链接的文件的 .data 字段集中放在这里 */ *(.data .data.*) } bss_start = .; /* .bss 字段 */ .bss : { /* 要链接的文件的 .bss 字段集中放在这里 */ *(.bss .bss.*) } boot_stack_start = .; /* stack 字段 */ .stack : { /* 把 bss.stack 字段所申请的空间放在这里作为启动时的栈空间 */ *(.bss.stack) } /* 结束地址 */ kernel_end = .; } } 时至今日我们已经不太可能将所有代码都写在一个文件里面。在编译过程中，我们的编译器和链接器已经给每个文件都自动生成了一个内存布局。这里，我们的链接工具所要做的是最终将各个文件的内存布局装配起来生成整个内核的内存布局。 我们首先使用 OUTPUT_ARCH 指定了架构，随后使用 ENTRY 指定了入口点为 _start 函数，即程序第一条被执行的指令所在之处。在这个链接脚本中我们并未看到 _start ，回忆上一章，我们为了移除运行时环境依赖，重写了入口 _start 。所以，链接脚本宣布整个程序会从那里开始运行。 链接脚本的整体写在 SECTION{ } 中，里面有多个形如 output section: { input section list } 的语句，每个都描述了整个程序内存布局中的一个输出段 output section 是由各个文件中的哪些输入段 input section 组成的。 我们可以用 *( ) 来表示将各个文件中所有符合括号内要求的输入段放在当前的位置。而括号内，你可以直接使用段的名字，也可以包含通配符 *。 单独的一个 . 为当前地址 (location counter)，可以对其赋值来从设置的地址继续向高地址放置各个段。如果不进行赋值的话，则默认各个段会紧挨着向高地址放置。将一个符号赋值为 . 则会记录下这个符号的地址。 到这里我们大概看懂了这个链接脚本在做些什么事情。首先是从 BASE_ADDRESS 即 0x80200000 开始向下放置各个段，依次是 .text，.rodata，.data，.stack 和 .bss。同时我们还记录下了每个段的开头和结尾地址，如 .text 段的开头、结尾地址分别就是符号 stext 和 etext 的值，我们接下来会用到。 [info] 为什么是 0x80200000 OpenSBI 将自身放在 0x80000000，完成初始化后会跳转到 0x80200000，因此 _start 必须位于这个地址。.text 为代码段标识，其第一个放置的就是 _start（即 .text.entry）。 这里面有两个输入段与其他的不太一样，即 .text.entry 和 .bss.stack，似乎编译器不会自动生成这样名字的段。事实上，它们是我们在后面自己定义的。 使用链接脚本 为了在编译时使用上面自定义的链接脚本，我们在 .cargo/config 文件中加入以下配置： os/.cargo/config # 使用我们的 linker script 来进行链接 [target.riscv64imac-unknown-none-elf] rustflags = [ \"-C\", \"link-arg=-Tsrc/linker/linker.ld\", ] 它的作用是在链接时传入一个参数 -T 来指定使用哪个链接脚本。 我们重新编译一下，然后再次查看生成的可执行文件： 运行输出 $ cargo build ... Finished dev [unoptimized + debuginfo] target(s) in 0.23s $ rust-objdump target/riscv64imac-unknown-none-elf/debug/os -h --arch-name=riscv64 target/riscv64imac-unknown-none-elf/debug/os: file format ELF64-riscv Sections: Idx Name Size VMA Type 0 00000000 0000000000000000 1 .text 0000000c 0000000080200000 TEXT 2 .rodata 00000000 000000008020000c TEXT 3 .data 00000000 000000008020000c TEXT 4 .bss 00000000 000000008020000c BSS ... $ rust-objdump target/riscv64imac-unknown-none-elf/debug/os -d --arch-name=riscv64 target/riscv64imac-unknown-none-elf/debug/os: file format ELF64-riscv Disassembly of section .text: 0000000080200000 stext: 80200000: 41 11 addi sp, sp, -16 80200002: 06 e4 sd ra, 8(sp) 80200004: 22 e0 sd s0, 0(sp) 80200006: 00 08 addi s0, sp, 16 80200008: 09 a0 j 2 8020000a: 01 a0 j 0 程序已经被正确地放在了指定的地址上。 到这里，我们清楚了最终程序的内存布局会长成什么样子。下一节我们来补充这个链接脚本中未定义的段，并完成编译。 "},"docs/lab-0/guide/part-7.html":{"url":"docs/lab-0/guide/part-7.html","title":"重写程序入口点","keywords":"","body":"重写程序入口点 _start 我们在第一章中，曾自己重写了一个入口点 _start，在那里我们仅仅只是让它死循环。但是现在，类似 C 语言运行时环境，我们希望这个函数可以为我们设置内核的运行环境。随后，我们才真正开始执行内核的代码。 但是具体而言我们需要设置怎样的运行环境呢？ [info] 第一条指令 在 CPU 加电或 Reset 后，它首先会进行自检（POST, Power-On Self-Test），通过自检后会跳转到启动代码（Bootloader）的入口。在 bootloader 中，我们进行外设探测，并对内核的运行环境进行初步设置。随后，bootloader 会将内核代码从硬盘加载到内存中，并跳转到内核入口，正式进入内核。也就是说，CPU 所执行的第一条指令其实是指 bootloader 的第一条指令。 幸运的是， 我们已经有现成的 bootloader 实现 OpenSBI 固件（Firmware）。 [info] Firmware 固件 在计算中，固件是一种特定的计算机软件，它为设备的特定硬件提供低级控制进一步加载其他软件的功能。固件可以为设备更复杂的软件（如操作系统）提供标准化的操作环境，或者，对于不太复杂的设备，充当设备的完整操作系统，执行所有控制、监视和数据操作功能。在基于 x86 的计算机系统中, BIOS 或 UEFI 是一种固件；在基于 RISC-V 的计算机系统中，OpenSBI 是一种固件。 OpenSBI 固件运行在特权级别很高的计算机硬件环境中，即 RISC-V 64 的 M Mode（CPU 加电后也就运行在 M Mode），我们将要实现的 OS 内核运行在 S Mode，而我们要支持的用户程序运行在 U Mode。在开发过程中我们重点关注 S Mode。 [info] RISC-V 64 的特权级 RISC-V 共有 3 种特权级，分别是 U Mode（User / Application 模式）、S Mode（Supervisor 模式）和 M Mode（Machine 模式）。 从 U 到 S 再到 M，权限不断提高，这意味着你可以使用更多的特权指令，访需求权限更高的寄存器等等。我们可以使用一些指令来修改 CPU 的当前特权级。而当当前特权级不足以执行特权指令或访问一些寄存器时，CPU 会通过某种方式告诉我们。 OpenSBI 所做的一件事情就是把 CPU 从 M Mode 切换到 S Mode，接着跳转到一个固定地址 0x80200000，开始执行内核代码。 [info] RISC-V 的 M Mode Machine 模式是 RISC-V 中可以执行的最高权限模式。在机器态下运行的代码对内存、I/O 和一些对于启动和配置系统来说必要的底层功能有着完全的使用权。 RISC-V 的 S Mode Supervisor 模式是支持现代类 Unix 操作系统的权限模式，支持现代类 Unix 操作系统所需要的基于页面的虚拟内存机制是其核心。 接着我们要在 _start 中设置内核的运行环境了，我们直接来看代码： os/src/asm/entry.asm # 操作系统启动时所需的指令以及字段 # # 我们在 linker.ld 中将程序入口设置为了 _start，因此在这里我们将填充这个标签 # 它将会执行一些必要操作，然后跳转至我们用 rust 编写的入口函数 # # 关于 RISC-V 下的汇编语言，可以参考 https://github.com/riscv/riscv-asm-manual/blob/master/riscv-asm.md .section .text.entry .globl _start # 目前 _start 的功能：将预留的栈空间写入 $sp，然后跳转至 rust_main _start: la sp, bootstacktop call rust_main # 回忆：bss 段是 ELF 文件中只记录长度，而全部初始化为 0 的一段内存空间 # 这里声明字段 .bss.stack 作为操作系统启动时的栈 .section .bss.stack .global bootstack bootstack: .space 4096 * 4 .global bootstacktop bootstacktop: # 栈结尾 可以看到之前未被定义的 .bss.stack 段出现了，我们只是在这里分配了一块 4096×4 Bytes=16 KBytes4096\\times{4}\\text{\\ Bytes}=16 \\text{\\ KBytes}4096×4 Bytes=16 KBytes 的内存作为启动时内核的栈。之前的 .text.entry 也出现了，也就是我们将 _start 函数放在了 .text 段的开头。 我们看看 _start 里面做了什么： 修改栈指针寄存器 sp 为 .bss.stack 段的结束地址，由于栈是从高地址往低地址增长，所以高地址是初始的栈顶； 使用 call 指令跳转到 rust_main 。这意味着我们的内核运行环境设置完成了，正式进入内核。 我们将 os/src/main.rs 里面的 _start 函数删除，并换成 rust_main ： os/src/main.rs //! # 全局属性 //! - `#![no_std]` //! 禁用标准库 #![no_std] //! //! - `#![no_main]` //! 不使用 `main` 函数等全部 Rust-level 入口点来作为程序入口 #![no_main] //! //! - `#![feature(global_asm)]` //! 内嵌整个汇编文件 #![feature(global_asm)] // 汇编编写的程序入口，具体见该文件 global_asm!(include_str!(\"asm/entry.asm\")); use core::panic::PanicInfo; /// 当 panic 发生时会调用该函数 /// 我们暂时将它的实现为一个死循环 #[panic_handler] fn panic(_info: &PanicInfo) -> ! { loop {} } /// Rust 的入口函数 /// /// 在 `_start` 为我们进行了一系列准备之后，这是第一个被调用的 Rust 函数 #[no_mangle] pub extern \"C\" fn rust_main() -> ! { loop {} } 到现在为止我们终于将一切都准备好了，接下来就要配合 OpenSBI 运行我们的内核！ "},"docs/lab-0/guide/part-8.html":{"url":"docs/lab-0/guide/part-8.html","title":"使用 QEMU 运行","keywords":"","body":"使用 QEMU 运行内核 使用 OpenSBI 新版 QEMU 中内置了 OpenSBI 固件，它主要负责在操作系统运行前的硬件初始化和加载操作系统的功能。我们使用以下命令尝试运行一下： 运行输出 $ qemu-system-riscv64 \\ --machine virt \\ --nographic \\ --bios default OpenSBI v0.4 (Jul 2 2019 11:53:53) ____ _____ ____ _____ / __ \\ / ____| _ \\_ _| | | | |_ __ ___ _ __ | (___ | |_) || | | | | | '_ \\ / _ \\ '_ \\ \\___ \\| _ 可以看到我们已经在 qemu-system-riscv64 模拟的 QEMU Virt Machine 硬件上将 OpenSBI 这个固件跑起来了。QEMU 可以使用 ctrl+a （macOS 为 control+a） 再按下 x 键退出。 加载内核镜像 为了确信我们已经跑起来了内核里面的代码，我们最好在 rust_main 里面加上简单的输出： os/src/main.rs //! # 全局属性 //! - `#![no_std]` //! 禁用标准库 #![no_std] //! //! - `#![no_main]` //! 不使用 `main` 函数等全部 Rust-level 入口点来作为程序入口 #![no_main] //! # 一些 unstable 的功能需要在 crate 层级声明后才可以使用 //! - `#![feature(asm)]` //! 内嵌汇编 #![feature(asm)] //! //! - `#![feature(global_asm)]` //! 内嵌整个汇编文件 #![feature(global_asm)] // 汇编编写的程序入口，具体见该文件 global_asm!(include_str!(\"asm/entry.asm\")); use core::panic::PanicInfo; /// 当 panic 发生时会调用该函数 /// 我们暂时将它的实现为一个死循环 #[panic_handler] fn panic(_info: &PanicInfo) -> ! { loop {} } /// 在屏幕上输出一个字符，目前我们先不用了解其实现原理 pub fn console_putchar(ch: u8) { let _ret: usize; let arg0: usize = ch as usize; let arg1: usize = 0; let arg2: usize = 0; let which: usize = 1; unsafe { asm!(\"ecall\" : \"={x10}\" (_ret) : \"{x10}\" (arg0), \"{x11}\" (arg1), \"{x12}\" (arg2), \"{x17}\" (which) : \"memory\" : \"volatile\" ); } } /// Rust 的入口函数 /// /// 在 `_start` 为我们进行了一系列准备之后，这是第一个被调用的 Rust 函数 #[no_mangle] pub extern \"C\" fn rust_main() -> ! { // 在屏幕上输出 \"OK\\n\" ，随后进入死循环 console_putchar(b'O'); console_putchar(b'K'); console_putchar(b'\\n'); loop {} } 这样，如果我们将内核镜像加载完成后，屏幕上出现了 OK ，就说明我们之前做的事情没有问题。 现在我们生成内核镜像要通过多条命令来完成，我们可以通过在 os 目录下建立一个 Makefile 来简化这一过程： os/Makefile TARGET := riscv64imac-unknown-none-elf MODE := debug KERNEL_FILE := target/$(TARGET)/$(MODE)/os BIN_FILE := target/$(TARGET)/$(MODE)/kernel.bin OBJDUMP := rust-objdump --arch-name=riscv64 OBJCOPY := rust-objcopy --binary-architecture=riscv64 .PHONY: doc kernel build clean qemu run env # 默认 build 为输出二进制文件 build: $(BIN_FILE) # 通过 Rust 文件中的注释生成 os 的文档 doc: @cargo doc --document-private-items # 编译 kernel kernel: @cargo build # 生成 kernel 的二进制文件 $(BIN_FILE): kernel @$(OBJCOPY) $(KERNEL_FILE) --strip-all -O binary $@ # 查看反汇编结果 asm: @$(OBJDUMP) -d $(KERNEL_FILE) | less # 清理编译出的文件 clean: @cargo clean # 运行 QEMU qemu: build @qemu-system-riscv64 \\ -machine virt \\ -nographic \\ -bios default \\ -device loader,file=$(BIN_FILE),addr=0x80200000 # 一键运行 run: build qemu 这里我们通过参数 -device 来将内核镜像加载到 QEMU 中，我们指定了内核镜像文件，并告诉 OpenSBI 最后跳转到 0x80200000 这个入口地址。 最后，我们可以使用 make run 来用 Qemu 加载内核镜像并运行。匆匆翻过一串长长的 OpenSBI 输出，我们看到了 OK！于是历经了千辛万苦我们终于将我们的内核跑起来了！ 下一节我们实现格式化输出来使得我们后续能够更加方便的通过输出来进行内核调试。 "},"docs/lab-0/guide/part-9.html":{"url":"docs/lab-0/guide/part-9.html","title":"接口封装和代码整理","keywords":"","body":"接口封装和代码整理 使用 OpenSBI 提供的服务 OpenSBI 实际上不仅起到了 bootloader 的作用，还为我们提供了一些服务供我们在编写内核时使用。这层接口称为 SBI（Supervisor Binary Interface），是 S Mode 的 OS 和 M Mode 执行环境之间的标准接口。 参考 OpenSBI 文档 ，我们会发现里面包含了一些以 C 函数格式给出的我们可以调用的接口。 上一节中我们的 console_putchar 函数类似于调用下面的接口来实现的： void sbi_console_putchar(int ch) 而实际的过程是这样的：我们通过 ecall 发起系统调用。OpenSBI 会检查发起的系统调用的编号，如果编号在 0-8 之间，则进行处理，否则交由我们自己的中断处理程序处理（暂未实现）。想进一步了解编号在 0-8 之间的系统调用，请参考看 OpenSBI 文档 执行 ecall 前需要指定系统调用的编号，传递参数。一般而言，a7 为系统调用编号，a0、a1 和 a2 为参数： os/src/sbi.rs //! 调用 Machine 层的操作 // 目前还不会用到全部的 SBI 调用，暂时允许未使用的变量或函数 #![allow(unused)] /// SBI 调用 #[inline(always)] fn sbi_call(which: usize, arg0: usize, arg1: usize, arg2: usize) -> usize { let ret; unsafe { asm!(\"ecall\" : \"={x10}\" (ret) : \"{x10}\" (arg0), \"{x11}\" (arg1), \"{x12}\" (arg2), \"{x17}\" (which) : \"memory\" // 如果汇编可能改变内存，则需要加入 memory 选项 : \"volatile\"); // \b\b\b防止编译器做激进的优化（如调换指令顺序等破坏 SBI 调用行为的优化） } ret } [info] 函数调用与 Calling convention 我们知道，编译器将高级语言源代码翻译成汇编代码。对于汇编语言而言，在最简单的编程模型中，所能够利用的只有指令集中提供的指令、各通用寄存器、 CPU 的状态、内存资源。那么，在高级语言中，我们进行一次函数调用，编译器要做哪些工作利用汇编语言来实现这一功能呢？ 显然并不是仅用一条指令跳转到被调用函数开头地址就行了。我们还需要考虑： 如何传递参数？ 如何传递返回值？ 如何保证函数返回后能从我们期望的位置继续执行？ 等更多事项。通常编译器按照某种规范去翻译所有的函数调用，这种规范被称为 Calling convention 。值得一提的是，为了实现函数调用，我们需要预先分配一块内存作为调用栈 ，后面会看到调用栈在函数调用过程中极其重要。你也可以理解为什么第一章刚开始我们就要分配栈了。 对于参数比较少且是基本数据类型的时候，我们从左到右使用寄存器 a0 到 a7 就可以完成参数的传递。具体规范可参考 RISC-V Calling Convention。 然而，如这种情况一样，设置寄存器并执行汇编指令，这超出了 Rust 语言的描述能力。然而又与之前 global_asm! 大段插入汇编代码不同，我们要把 u8 类型的单个字符传给 a0 作为输入参数，这种情况较为强调 Rust 与汇编代码的交互。此时我们通常使用内联汇编（Inline Assembly），具体规范请参考这里。 输出部分，我们将结果保存到变量 ret 中，限制条件 {x10} 告诉编译器使用寄存器 x10（即 a0 寄存器），前面的 = 表明汇编代码会修改该寄存器并作为最后的返回值。 输入部分，我们分别通过寄存器 x10、x11、x12 和 x17（这四个寄存器又名 a0、a1、a2 和 a7） 传入参数 arg0、arg1、arg2 和 which ，其中前三个参数分别代表接口可能所需的三个输入参数，最后一个 which 用来区分我们调用的是哪个接口（SBI Extension ID）。这里之所以提供三个输入参数是为了将所有接口囊括进去，对于某些接口有的输入参数是冗余的，比如 sbi_console_putchar 由于只需一个输入参数，它就只关心寄存器 a0 的值。 接着利用 sbi_call 函数参考 OpenSBI 文档实现对应的接口，顺带也可以把关机函数通过 SBI 接口一并实现： os/src/sbi.rs const SBI_SET_TIMER: usize = 0; const SBI_CONSOLE_PUTCHAR: usize = 1; const SBI_CONSOLE_GETCHAR: usize = 2; const SBI_CLEAR_IPI: usize = 3; const SBI_SEND_IPI: usize = 4; const SBI_REMOTE_FENCE_I: usize = 5; const SBI_REMOTE_SFENCE_VMA: usize = 6; const SBI_REMOTE_SFENCE_VMA_ASID: usize = 7; const SBI_SHUTDOWN: usize = 8; /// 向控制台输出一个字符 /// /// 需要注意我们不能直接使用 Rust 中的 char 类型 pub fn console_putchar(c: usize) { sbi_call(SBI_CONSOLE_PUTCHAR, c, 0, 0); } /// 从控制台中读取一个字符 /// /// 没有读取到字符则返回 -1 pub fn console_getchar() -> usize { sbi_call(SBI_CONSOLE_GETCHAR, 0, 0, 0) } /// 调用 SBI_SHUTDOWN 来关闭操作系统（直接退出 QEMU） pub fn shutdown() -> ! { sbi_call(SBI_SHUTDOWN, 0, 0, 0); unreachable!() } 现在我们比较深入的理解了 console_putchar 到底是怎么一回事。下面我们使用 console_putchar 实现格式化输出，为后面的调试提供方便。 实现格式化输出 只能使用 console_putchar 这种苍白无力的输出手段让人头皮发麻。如果我们能使用 println! 宏的话该有多好啊！于是我们就来实现自己的 print!宏和 println!宏！ 我们将这一部分放在 os/src/conosle.rs 中，关于格式化输出，Rust 中提供了一个接口 core::fmt::Write，你需要实现函数： fn write_str(&mut self, s: &str) -> Result 随后我们就可以调用如下函数（会进一步调用write_str 实现函数）来进行显示： fn write_fmt(mut self: &mut Self, args: Arguments) -> Result write_fmt 函数需要处理 Arguments 类封装的输出字符串。而我们已经有现成的 format_args! 宏，它可以将模式字符串和参数列表的输入转化为 Arguments 类，比如 format_args!(\"{} {}\", 1, 2) 。 因此，我们宏的实现思路便为： 解析传入参数，转化为 format_args! 可接受的输入（事实上原封不动就行了），并通过 format_args! 宏得到 Arguments 类 调用 write_fmt 函数输出这个类 而为了调用 write_fmt 函数，我们必须实现 write_str 函数，而它可用 console_putchar 函数来实现。 最后，我们把整个 print 和 println 宏按照逻辑写出即可，整体逻辑的代码如下： os/src/console.rs //! 实现控制台的字符输入和输出 //! //! # 格式化输出 //! //! [`core::fmt::Write`] trait 包含 //! - 需要实现的 [`write_str`] 方法 //! - 自带实现，但依赖于 [`write_str`] 的 [`write_fmt`] 方法 //! //! 我们声明一个类型，为其实现 [`write_str`] 方法后，就可以使用 [`write_fmt`] 来进行格式化输出 //! //! [`write_str`]: core::fmt::Write::write_str //! [`write_fmt`]: core::fmt::Write::write_fmt use crate::sbi::*; use core::fmt::{self, Write}; /// 一个 [Zero-Sized Type]，实现 [`core::fmt::Write`] trait 来进行格式化输出 /// /// ZST 只可能有一个值（即为空），因此它本身就是一个单件 struct Stdout; impl Write for Stdout { /// 打印一个字符串 /// /// 对于每一个字符调用 [`console_putchar`] fn write_str(&mut self, s: &str) -> fmt::Result { for c in s.chars() { console_putchar(c as usize); } Ok(()) } } /// 打印由 [`core::format_args!`] 格式化后的数据 /// /// [`print!`] 和 [`println!`] 宏都将展开成此函数 /// /// [`core::format_args!`]: https://doc.rust-lang.org/nightly/core/macro.format_args.html pub fn print(args: fmt::Arguments) { Stdout.write_fmt(args).unwrap(); } /// 实现类似于标准库中的 `print!` 宏 /// /// 使用实现了 [`core::fmt::Write`] trait 的 [`console::Stdout`] #[macro_export] macro_rules! print { ($fmt: literal $(, $($arg: tt)+)?) => { $crate::console::print(format_args!($fmt $(, $($arg)+)?)); } } /// 实现类似于标准库中的 `println!` 宏 /// /// 使用实现了 [`core::fmt::Write`] trait 的 [`console::Stdout`] #[macro_export] macro_rules! println { ($fmt: literal $(, $($arg: tt)+)?) => { $crate::console::print(format_args!(concat!($fmt, \"\\n\") $(, $($arg)+)?)); } } 整理 panic 处理模块 最后，我们用刚刚实现的格式化输出和关机的函数，将 main.rs 中处理 panic 的语义项抽取并完善到 panic.rs 中： os/src/panic.rs //! 代替 std 库，实现 panic 和 abort 的功能 use core::panic::PanicInfo; use crate::sbi::shutdown; /// 打印 panic 的信息并 [`shutdown`] /// /// ### `#[panic_handler]` 属性 /// 声明此函数是 panic 的回调 #[panic_handler] fn panic_handler(info: &PanicInfo) -> ! { // `\\x1b[??m` 是控制终端字符输出格式的指令，在支持的平台上可以改变文字颜色等等 // 这里使用错误红 // 需要全局开启 feature(panic_info_message) 才可以调用 .message() 函数 // 参考：https://misc.flogisoft.com/bash/tip_colors_and_formatting println!(\"\\x1b[1;31mpanic: '{}'\\x1b[0m\", info.message().unwrap()); shutdown() } /// 终止程序 /// /// 调用 [`panic_handler`] #[no_mangle] extern \"C\" fn abort() -> ! { panic!(\"abort()\") } 检验我们的成果 最后，我们可以 os/src/main.rs 中去掉之前写的 console_putchar并调用我们新写的一系列函数，并在 Rust 入口处加入一些简单的输出看一看我们的逻辑是否正确： os/src/main.rs //! # 全局属性 //! - `#![no_std]` //! 禁用标准库 #![no_std] //! //! - `#![no_main]` //! 不使用 `main` 函数等全部 Rust-level 入口点来作为程序入口 #![no_main] //! //! - `#![deny(missing_docs)]` //! 任何没有注释的地方都会产生警告：这个属性用来压榨写实验指导的学长，同学可以删掉了 #![warn(missing_docs)] //! # 一些 unstable 的功能需要在 crate 层级声明后才可以使用 //! - `#![feature(asm)]` //! 内嵌汇编 #![feature(asm)] //! //! - `#![feature(global_asm)]` //! 内嵌整个汇编文件 #![feature(global_asm)] //! //! - `#![feature(panic_info_message)]` //! panic! 时，获取其中的信息并打印 #![feature(panic_info_message)] #[macro_use] mod console; mod panic; mod sbi; // 汇编编写的程序入口，具体见该文件 global_asm!(include_str!(\"asm/entry.asm\")); /// Rust 的入口函数 /// /// 在 `_start` 为我们进行了一系列准备之后，这是第一个被调用的 Rust 函数 #[no_mangle] pub extern \"C\" fn rust_main() -> ! { println!(\"Hello rCore-Tutorial!\"); panic!(\"end of rust_main\") } 在命令行中输入 make run，我们成功看到了 println 宏输出的 Hello rCore-Tutorial! 和一行红色的 panic: 'end of rust_main'！ "},"docs/lab-0/guide/summary.html":{"url":"docs/lab-0/guide/summary.html","title":"小结","keywords":"","body":"小结 本章作为一个预备实验，用 Rust 实现了一个最小化的内核，并成功通过 QEMU 中的 OpenSBI 启动了我们的内核。在下一章中，我们会和硬件进一步打交道，实现中断机制。 本章没有具体的习题，本章部分将会在后面正式的实验中进行考察。 "},"docs/lab-1/guide/intro.html":{"url":"docs/lab-1/guide/intro.html","title":"摘要","keywords":"","body":"实验指导一 实验概要 这一章的实验指导中，我们将会学习 RISC-V 中有关中断处理的寄存器和相关流程 如何保存上下文，使得中断处理流程前后，原本正在执行的程序感知不到发生了中断 处理最简单的断点中断和时钟中断 实验题：TODO 实验说明 中断是我们在操作系统上首先实现的功能，因为它是操作系统所有功能的基础。假如没有中断，操作系统在唤起一个用户程序之后，就只能等到用户程序执行完成之后才能继续执行，那操作系统完全无法进行资源调度。 在我们的框架中，中断的处理过程是这样的： 操作系统初始化时，开启中断 程序执行触发中断，或硬件发生中断 硬件检查操作系统设置的中断使能（sie），如果中断使能打开，则进入中断 硬件根据 stvec 中的值找到中断处理函数入口，它被我们设置为 __interrupt 汇编标签的地址 __interrupt 保存各种寄存器，然后调用 handle_interrupt 根据不同的中断类型进行处理 处理完成后，执行 __restore，恢复各种寄存器 最终，通过 sret 指令跳转至 sepc 寄存器保存的值 "},"docs/lab-1/guide/part-1.html":{"url":"docs/lab-1/guide/part-1.html","title":"背景知识","keywords":"","body":"背景知识 一个比喻 操作系统就像家长，他将孩子（用户程序）送到学校（开始运行）之后便不再管。 但是如果孩子闯了祸，老师（硬件）就找到家长，这便是异常。 孩子的作业可能需要家长来签字（系统调用），他就会主动找家长，这便是陷阱 放学时间（时钟中断）到，那么不管孩子想不想回家，家长都会把他接走，这便是硬件中断 中断的种类 异常（Exception） 执行指令时产生的，通常无法预料的错误。例如：访问无效内存地址、执行非法指令（除以零）等。 有的异常可以恢复，例如缺页异常；有的异常会导致用户程序被终止，例如非法访问。 陷阱（Trap） 陷阱是一系列强行导致中断的指令，例如：系统调用（syscall）等。 硬件中断（Hardware Interrupt） 前两种都是指令导致的异常，而硬件中断是由 CPU 之外的硬件产生的异步中断，例如：时钟中断、外设发来数据等。 "},"docs/lab-1/guide/part-2.html":{"url":"docs/lab-1/guide/part-2.html","title":"RISC-V 中的中断","keywords":"","body":"RISC-V 与中断相关的寄存器和指令 [info] 回顾：RISC-V 中的机器态（Machine mode，机器模式，M 模式） 是 RISC-V 中的最高权限模式，一些底层操作的指令只能由机器态进行使用。 是所有标准 RISC-V 处理器都必须实现的模式。 默认所有中断实际上是交给机器态处理的，但是为了实现更多功能，机器态会将某些中断交由内核态处理。这些异常也正是我们编写操作系统所需要实现的。 回顾：RISC-V 中的内核态（Supervisor mode，内核模式，S 模式） 通常为操作系统使用，可以访问一些 supervisor 级别的寄存器，通过这些寄存器对中断和虚拟内存映射进行管理。 Unix 系统中，大部分的中断都是内核态的系统调用。机器态可以通过异常委托机制（machine interrupt delegation）将一部分中断设置为不经过机器态，直接由内核态处理 在实验中，我们主要关心的就是内核态可以使用的一些特权指令和寄存器。其中关于中断的会在本章用到，而关于内存映射的部分将会在第三部分用到。 与中断相关的寄存器 在内核态和机器态中，RISC-V 设计了一些 CSR（Control and Status Registers）寄存器用来保存控制信息。目前我们关心的是其中涉及到控制中断的寄存器。 发生中断时，硬件自动填写的寄存器 sepc即 Exception Program Counter，用来记录触发中断的指令的地址。 和我们之前学的 MIPS 32 系统不同，RISC-V 中不需要考虑延迟槽的问题。但是 RISC-V 中的指令不定长，如果中断处理需要恢复到异常指令后一条指令进行执行，就需要正确判断将 pc 寄存器加上多少字节。 scause记录中断是否是硬件中断，以及具体的中断原因。 stvalscause 不足以存下中断所有的必须信息。例如缺页异常，就会将 stval 设置成需要访问但是不在内存中的地址，以便于操作系统将这个地址所在的页面加载进来。 指导硬件处理中断的寄存器 stvec设置内核态中断处理流程的入口地址。存储了一个基址 BASE 和模式 MODE： MODE 为 0 表示 Direct 模式，即遇到中断便跳转至 BASE 进行执行。 MODE 为 1 表示 Vectored 模式，此时 BASE 应当指向一个向量，存有不同处理流程的地址，遇到中断会跳转至 BASE + 4 * cause 进行处理流程。 sstatus具有许多状态位，控制全局中断使能等。 sie即 Supervisor Interrupt-Enable，用来控制具体类型中断的使能，例如其中的 STIE 控制时钟中断使能。 sip即 Supervisor Interrupt-Pending，和 sie 相对应，记录每种中断是否被触发。仅当 sie 和 sip 的对应位都为 1 时，意味着开中断且已发生中断，这时中断最终触发。 sscratch （这个寄存器的用处会在实现线程时起到作用，目前仅了解即可） 在用户态，sscratch 保存内核栈的地址；在内核态，sscratch 的值为 0。 为了能够执行内核态的中断处理流程，仅有一个入口地址是不够的。中断处理流程很可能需要使用栈，而程序当前的用户栈是不安全的。因此，我们还需要一个预设的安全的栈空间，存放在这里。 在内核态中，sp 可以认为是一个安全的栈空间，sscratch 便不需要保存任何值。此时将其设为 0，可以在遇到中断时通过 sscratch 中的值判断中断前程序是否处于内核态。 与中断相关的指令 进入和退出中断 ecall触发中断，进入更高一层的中断处理流程之中。用户态进行系统调用进入内核态中断处理流程，内核态进行 SBI 调用进入机器态中断处理流程，使用的都是这条指令。 sret从内核态返回用户态，同时将 pc 的值设置为 sepc。（如果需要返回到 sepc 后一条指令，就需要在 sret 之前修改 sepc 的值） ebreak触发一个断点。 mret从机器态返回内核态，同时将 pc 的值设置为 mepc。 操作 CSR 只有一系列特殊的指令（CSR Instruction）可以读写 CSR。尽管所有模式都可以使用这些指令，用户态只能只读的访问某几个寄存器。 为了让操作 CSR 的指令不被干扰，许多 CSR 指令都是结合了读写的原子操作。不过在实验中，我们只用到几个简单的指令。 csrrw dst, csr, src（CSR Read Write）同时读写的原子操作，将指定 CSR 的值写入 dst，同时将 src 的值写入 CSR。 csrr dst, csr（CSR Read）仅读取一个 CSR 寄存器。 csrw csr, src（CSR Write）仅写入一个 CSR 寄存器。 csrc(i) csr, rs1（CSR Clear）将 CSR 寄存器中指定的位清零，csrc 使用通用寄存器作为 mask，csrci 则使用立即数。 csrs(i) csr, rs1（CSR Set）将 CSR 寄存器中指定的位置 1，csrc 使用通用寄存器作为 mask，csrci 则使用立即数。 了解更多 RISC-V 官方文档： CSR 寄存器（Chapter 4，p59）https://content.riscv.org/wp-content/uploads/2017/05/riscv-privileged-v1.10.pdf CSR 指令（Section 2.8，p33）https://content.riscv.org/wp-content/uploads/2017/05/riscv-spec-v2.2.pdf "},"docs/lab-1/guide/part-3.html":{"url":"docs/lab-1/guide/part-3.html","title":"程序运行状态","keywords":"","body":"程序运行状态 对于用户程序而言，中断的处理应当是不留任何痕迹的：只要中断处理改动了一个寄存器，都可能导致原本正在运行的线程出现错误。因此，在处理中断之前，必须要保存所有可能被修改的寄存器，并且在处理完成后恢复。因此，我们需要保存所有通用寄存器，sepc、scause 和 stval 这三个会被硬件自动写入的 CSR 寄存器，以及 sstatus。因为中断可能会涉及到权限的切换，以及中断的开关，这些都会修改 sstatus。 TrapFrame 我们把在中断时保存了各种寄存器的组构体叫做 TrapFrame，其定义如下： os/src/interrupt/trap_frame.rs use riscv::register::{sstatus::Sstatus, scause::Scause}; #[repr(C)] pub struct TrapFrame { pub x: [usize; 32], // 32 个通用寄存器 pub sstatus: Sstatus, pub sepc: usize, pub scause: Scause, pub stval: usize, } 这里我们使用了 rCore 中的库 riscv 封装的一些寄存器操作，需要在 os/Cargo.toml 中添加依赖。 os/Cargo.toml [dependencies] riscv = { git = \"https://github.com/rcore-os/riscv\", features = [\"inline-asm\"] } "},"docs/lab-1/guide/part-4.html":{"url":"docs/lab-1/guide/part-4.html","title":"状态的保存与恢复","keywords":"","body":"状态的保存与恢复 操作流程 为了状态的保存与恢复，我们可以先用栈上的一小段空间来把需要保存的全部通用寄存器和 CSR 寄存器保存在栈上，保存完之后在跳转到 Rust 编写的中断处理函数；而对于恢复，则直接把备份在栈上的内容写回寄存器。由于涉及到了寄存器级别的操作，我们需要用汇编来实现。 而对于如何保存在栈上，我们可以直接令 sp 栈寄存器直接减去相应需要开辟的大小，然后依次放在栈上。需要注意的是，sp 寄存器又名 x2，我们需要不断用到这个寄存器告诉 CPU 其他寄存器放在哪个地址，所以处理这个 sp 寄存器本身的保存时也需要格外小心。 编写汇编 因为汇编代码较长，这里我们新建一个 os/src/asm/interrupt.asm 文件来编写这段操作： os/src/asm/interrupt.asm # 宏：将寄存器存到栈上 .macro SAVE reg, offset sd \\reg, \\offset*8(sp) .endm # 宏：将寄存器从栈中取出 .macro LOAD reg, offset ld \\reg, \\offset*8(sp) .endm # 宏：保存所有寄存器到 TrapFrame .macro SAVE_ALL # 在栈上开辟 TrapFrame 所需的空间 addi sp, sp, -36*8 # 保存通用寄存器，除了 x0（固定为 0） SAVE x1, 1 addi x1, sp, 36*8 # 将原来的 sp（sp 又名 x2）写入 2 位置 SAVE x1, 2 SAVE x3, 3 SAVE x4, 4 SAVE x5, 5 SAVE x6, 6 SAVE x7, 7 SAVE x8, 8 SAVE x9, 9 SAVE x10, 10 SAVE x11, 11 SAVE x12, 12 SAVE x13, 13 SAVE x14, 14 SAVE x15, 15 SAVE x16, 16 SAVE x17, 17 SAVE x18, 18 SAVE x19, 19 SAVE x20, 20 SAVE x21, 21 SAVE x22, 22 SAVE x23, 23 SAVE x24, 24 SAVE x25, 25 SAVE x26, 26 SAVE x27, 27 SAVE x28, 28 SAVE x29, 29 SAVE x30, 30 SAVE x31, 31 # 取出 CSR 并保存 csrr s1, sstatus csrr s2, sepc csrr s3, scause csrr s4, stval SAVE s1, 32 SAVE s2, 33 SAVE s3, 34 SAVE s4, 35 .endm # 宏：恢复 TrapFrame 中所有寄存器 .macro LOAD_ALL # 恢复 CSR LOAD s1, 32 LOAD s2, 33 # 思考：为什么不恢复 scause 和 stval？如果不恢复，为什么之前要保存 csrw sstatus, s1 csrw sepc, s2 # 恢复通用寄存器 LOAD x1, 1 LOAD x3, 3 LOAD x4, 4 LOAD x5, 5 LOAD x6, 6 LOAD x7, 7 LOAD x8, 8 LOAD x9, 9 LOAD x10, 10 LOAD x11, 11 LOAD x12, 12 LOAD x13, 13 LOAD x14, 14 LOAD x15, 15 LOAD x16, 16 LOAD x17, 17 LOAD x18, 18 LOAD x19, 19 LOAD x20, 20 LOAD x21, 21 LOAD x22, 22 LOAD x23, 23 LOAD x24, 24 LOAD x25, 25 LOAD x26, 26 LOAD x27, 27 LOAD x28, 28 LOAD x29, 29 LOAD x30, 30 LOAD x31, 31 # 恢复 sp（又名 x2）这里最后恢复是为了上面可以正常使用 LOAD 宏 LOAD x2, 2 .endm .section .text .globl __interrupt # 进入中断 # 保存 TrapFrame 并且进入 rust 中的中断处理函数 interrupt::handler::handle_interrupt() __interrupt: SAVE_ALL # TrapFrame 作为参数 a0 传入 mv a0, sp jal handle_interrupt .globl __restore # 离开中断 # 从 TrapFrame 中恢复所有寄存器，并跳转至 TrapFrame 中 sepc 的位置 __restore: LOAD_ALL sret 思考 为什么保存时保存了四个 CSR 寄存器，而恢复时只恢复了 sstatus 和 sepc 这两个？ Click to show 保存寄存器有两种情况： 一种是通用寄存器和 sstatus：保存到 TrapFrame，使用寄存器进行中断处理流程，从 TrapFrame 中恢复这样即便中间再发生中断，也不会影响处理流程； 一种是其他 CSR 寄存器：被硬件自动设置，保存到 TrapFrame，从 TrapFrame 中读取进行中断处理这样即便中间再发生中断，原本中断的处理流程读取的是已保存的 TrapFrame，也不会受到影响。 而 sepc 则比较特殊，它实际上会被操作系统进行修改，从 TrapFrame 中恢复时后，会立即在 sret 中使用，替代当前的 pc，使得程序执行流回到中断前的程序中。 "},"docs/lab-1/guide/part-5.html":{"url":"docs/lab-1/guide/part-5.html","title":"进入中断处理流程","keywords":"","body":"进入中断处理流程 接下来，我们将要手动触发一个 Trap（ebreak），并且进入中断处理流程。 开启中断 为了让硬件能够找到我们编写的 __interrupt 入口，在操作系统初始化时，需要将其写入 stvec 寄存器中： os/src/interrupt/handler.rs use super::trap_frame::TrapFrame; use riscv::register::stvec; global_asm!(include_str!(\"../asm/interrupt.asm\")); /// 初始化中断处理 /// /// 把中断入口 `__interrupt` 写入 `stvec` 中，并且开启中断使能 pub fn init() { unsafe { extern \"C\" { /// `interrupt.asm` 中的中断入口 fn __interrupt(); } // 使用 Direct 模式，将中断入口设置为 `__interrupt` stvec::write(__interrupt as usize, stvec::TrapMode::Direct); } } 处理中断 然后，我们再补上 __interrupt 后跳转的中断处理流程 handle_interrupt()： os/src/interrupt/handler.rs /// 中断的处理入口 /// /// `interrupt.asm` 首先保存寄存器至 TrapFrame，其作为参数传入此函数 /// 具体的中断类型需要根据 TrapFram::scause 来推断，然后分别处理 #[no_mangle] pub fn handle_interrupt(trap_frame: &mut TrapFrame) { panic!(\"Interrupted: {:?}\", trap_frame.scause.cause()); } 触发中断 最后，我们把刚刚写的函数封装一下： os/src/interrupt/mod.rs //! 中断模块 //! //! mod handler; mod trap_frame; /// 初始化中断相关的子模块 /// /// - [`handler::init`] /// - [`timer::init`] pub fn init() { handler::init(); println!(\"mod interrupt initialized\"); } 同时，我们在 main 函数中主动使用 ebreak 来触发一个中断。 os/src/main.rs ... mod interrupt; ... /// Rust 的入口函数 /// /// 在 `_start` 为我们进行了一系列准备之后，这是第一个被调用的 Rust 函数 pub extern \"C\" fn rust_main() -> ! { // 初始化各种模块 interrupt::init(); unsafe { asm!(\"ebreak\"::::\"volatile\"); }; unreachable!(); } 运行一下，可以看到 ebreak 导致程序进入了中断处理并退出，而没有执行到后面的 unreachable!()： 运行输出 Hello rCore-Tutorial! mod interrupt initialized panic: 'Interrupted: Exception(Breakpoint)' "},"docs/lab-1/guide/part-6.html":{"url":"docs/lab-1/guide/part-6.html","title":"时钟中断","keywords":"","body":"时钟中断 本章的最后，我们来实现操作系统中极其重要的时钟中断。时钟中断是操作系统能够进行线程调度的基础，操作系统会在每次时钟中断时被唤醒，暂停正在执行的线程，并根据调度算法选择下一个应当运行的线程。 [info] RISC-V 中断寄存器的细分 在前面提到，sie 和 sip 寄存器分别保存不同中断种类的使能和触发记录。例如，软件中断的使能是 sie 中的 SSIE 位，触发记录是 sip 中的 SSIP 位。 RISC-V 中将中断分为三种： 软件中断（Software Interrupt），对应 SSIE 和 SSIP 时钟中断（Timer Interrupt），对应 STIE 和 STIP 外部中断（External Interrupt），对应 SEIE 和 SEIP 开启时钟中断 时钟中断也需要我们在初始化操作系统时开启，我们同样只需使用 riscv 库中提供的接口即可。 os/src/interrupt/timer.rs //! 预约和处理时钟中断 use crate::sbi::set_timer; use riscv::register::{time, sie, sstatus}; /// 初始化时钟中断 /// /// 开启时钟中断使能，并且预约第一次时钟中断 pub fn init() { unsafe { // 开启 STIE，允许时钟中断 sie::set_stimer(); // 开启 SIE（不是 sie 寄存器），允许内核态被中断打断 sstatus::set_sie(); } // 设置下一次时钟中断 set_next_timeout(); } 这里可能引起误解的是 sstatus::set_sie()，它的作用是开启 sstatus 寄存器中的 SIE 位，与 sie 寄存器无关。SIE 位决定中断是否能够打断 supervisor 线程。在这里我们需要允许时钟中断打断 内核态线程，因此置 SIE 位为 1。另外，无论 SIE 位为什么值，中断都可以打断用户态的线程。 设置时钟中断 每一次的时钟中断都需要操作系统设置一个下一次中断的时间，硬件会在指定的时间发出时钟中断。不过要做到这件事情，我们需要用到 SBI 的接口。SBI 会自动帮我们设置下一次要触发时钟中断的时间，当 CPU 发现执行完某条指令之后，将会检查当前的周期是否已经超过设置的时间，如果超时则会触发时钟中断。 os/src/sbi.rs /// 设置下一次时钟中断的时间 pub fn set_timer(time: usize) { sbi_call(SBI_SET_TIMER, time, 0, 0); } 为了便于后续处理，我们设置时钟间隔为 100000 个 CPU 周期。越短的间隔可以让 CPU 调度资源更加细致，但同时也会导致更多资源浪费在操作系统上。 os/src/interrupt/timer.rs /// 时钟中断的间隔，单位是 CPU 指令 static INTERVAL: usize = 100000; /// 设置下一次时钟中断 /// /// 获取当前时间，加上中断间隔，通过 SBI 调用预约下一次中断 fn set_next_timeout() { set_timer(time::read() + INTERVAL); } 由于没有一个接口来设置固定重复的时间中断间隔，因此我们需要在每一次时钟中断时，设置再下一次的时钟中断。 os/src/interrupt/timer.rs /// 触发时钟中断计数 pub static mut TICKS: usize = 0; /// 每一次时钟中断时调用 /// /// 设置下一次时钟中断，同时计数 +1 pub fn tick() { set_next_timeout(); unsafe { TICKS += 1; if TICKS % 100 == 0 { println!(\"100 ticks~\"); } } } 实现时钟中断的处理流程 接下来，我们在 handle_interrupt() 根据不同中断种类进行不同的处理流程。 os/src/interrupt/handler.rs use super::timer; use super::trap_frame::TrapFrame; use riscv::register::{ stvec, scause::{Trap, Exception, Interrupt}, }; ... /// 中断的处理入口 /// /// `interrupt.asm` 首先保存寄存器至 TrapFrame，其作为参数传入此函数 /// 具体的中断类型需要根据 TrapFram::scause 来推断，然后分别处理 #[no_mangle] pub fn handle_interrupt(trap_frame: &mut TrapFrame) { // 可以通过 Debug 来查看发生了什么中断 // println!(\"{:x?}\", trap_frame.scause.cause()); match trap_frame.scause.cause() { // 断点中断（ebreak） Trap::Exception(Exception::Breakpoint) => breakpoint(trap_frame), // 时钟中断 Trap::Interrupt(Interrupt::SupervisorTimer) => supervisor_timer(trap_frame), // 其他情况未实现 trap => unimplemented!(\"{:?}\", trap), } } /// 处理 ebreak 断点 /// /// 继续执行，其中 `sepc` 增加 2 字节，以跳过当前这条 `ebreak` 指令 fn breakpoint(trap_frame: &mut TrapFrame) { println!(\"Breakpoint at 0x{:x}\", trap_frame.sepc); trap_frame.sepc += 2; } /// 处理时钟中断 /// /// 目前只会在 [`timer`] 模块中进行计数 fn supervisor_timer(_: &TrapFrame) { timer::tick(); } 至此，时钟中断就可以正常工作了。我们在 os/interrupt/mod.rs 中引入 mod timer 并在 初始化 handler::init() 语句的后面加入 timer::init() 就成功加载了模块。 最后我们在 main 函数中去掉 unreachable!() 并插入 loop {} 防止程序退出，然后观察时钟中断。应当可以看到程序每隔一秒左右输出一次 100 ticks~。 "},"docs/lab-1/guide/summary.html":{"url":"docs/lab-1/guide/summary.html","title":"小结","keywords":"","body":"小结 本章完成了 RISC-V 中有关中断处理的部分，我们实现了上下文的保存和切换，使得原来正在的运行的程序不需要做任何处理就可以让操作系统处理好中断。实验性的，我们完成了简单的断点中断和时钟中断，为后面的章节打下了一定的基础。 在下一章节中，我们将从物理内存的管理出发，让操作系统真正可以去管理我们的可以使用的内存。 "},"docs/lab-2/guide/intro.html":{"url":"docs/lab-2/guide/intro.html","title":"摘要","keywords":"","body":"实验指导二 实验概要 这一章的实验指导中，你将会学到： 实现动态内存的分配 了解 QEMU 虚拟的物理内存 通过页的方式对物理内存进行管理 实验说明 实验指导的部分只包含如何一步步构建我们的目标，并不是练习题。如果你没有兴趣，你不需要完整跟着整个指导去动手做这件事情。但是也许你需要完整的阅读，这将对构建完整的操作系统概念和做练习题有很大帮助。 我们也提供了本章结束后完整的代码实现，你的练习题只需要基于我们给出的版本上增量实现即可。 "},"docs/lab-2/guide/part-1.html":{"url":"docs/lab-2/guide/part-1.html","title":"动态内存分配","keywords":"","body":"动态内存分配 我们之前在 C++ 语言等中使用过 malloc 等动态内存分配方法，与在编译期就已完成的静态内存分配相比，动态内存分配可以根据程序运行时状态修改内存申请的时机及大小，显得更为灵活，但是这是需要操作系统的支持的，同时也会带来一些开销。 我们的内核中也需要动态内存分配。典型的应用场景有： Box ，你可以理解为它和 malloc 有着相同的功能； 引用计数 Rc，原子引用计数 Arc，主要用于在引用计数清零，即某对象不再被引用时，对该对象进行自动回收； 一些 std 中的数据结构，如 Vec 和 HashMap 等。 为了在我们的内核中支持动态内存分配，在 Rust 语言中，我们需要实现 Trait GlobalAlloc，将这个类实例化，并使用语义项 #[global_allocator] 进行标记。这样的话，编译器就会知道如何进行动态内存分配。 为了实现 Trait GlobalAlloc，我们需要支持这么两个函数： unsafe fn alloc(&self, layout: Layout) -> *mut u8; unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout); 可见我们要分配/回收一块虚拟内存。 那么这里面的 Layout 又是什么呢？从文档中可以找到，它有两个字段：size 表示要分配的字节数，align 则表示分配的虚拟地址的最小对齐要求，即分配的地址要求是 align 的倍数。这里的 align 必须是 2 的幂次。 也就表示，我们的需求是分配一块连续的、大小至少为 size 字节的虚拟内存，且对齐要求为 align 。 连续内存分配算法 假设我们已经有一整块虚拟内存用来分配，那么如何进行分配呢？ 我们可能会想到一些简单粗暴的方法，比如对于一个分配任务，贪心地将其分配到可行的最小地址去。这样一直分配下去的话，我们分配出去的内存都是连续的，看上去很合理的利用了内存。 但是一旦涉及到回收的话，设想我们在连续分配出去的很多块内存中间突然回收掉一块，它虽然是可用的，但是由于上下两边都已经被分配出去，它就只有这么大而不能再被拓展了，这种可用的内存我们称之为外碎片。 随着不断回收会产生越来越多的碎片，某个时刻我们可能会发现，需要分配一块较大的内存，几个碎片加起来大小是足够的，但是单个碎片是不够的。我们会想到通过碎片整理将几个碎片合并起来。但是这个过程的开销极大。 老师在课堂上介绍了若干管理分配和碎片的算法，包括伙伴系统（Buddy System）和 SLAB 分配器等算法，我们在这里使用 Buddy System 来实现这件事情。 支持动态内存分配 为了避免重复造轮子，我们可以直接开一个静态的 8M 数组作为堆的空间，然后调用开源的 Buddy System Allocator。 os/src/memory/config.rs /// 操作系统动态分配内存所用的堆大小（8M） pub const KERNEL_HEAP_SIZE: usize = 0x80_0000; os/src/memory/heap.rs //! 实现操作系统动态内存分配所用的堆 //! //! 基于 `buddy_system_allocator` crate，致敬杰哥。 use super::config::KERNEL_HEAP_SIZE; use buddy_system_allocator::LockedHeap; /// 进行动态内存分配所用的堆空间 /// /// 大小为 [`KERNEL_HEAP_SIZE`] /// 这段空间编译后会被放在操作系统执行程序的 bss 段 static mut HEAP_SPACE: [u8; KERNEL_HEAP_SIZE] = [0; KERNEL_HEAP_SIZE]; /// 堆，动态内存分配器 /// /// ### `#[global_allocator]` /// [`LockedHeap`] 实现了 [`alloc::alloc::GlobalAlloc`] trait， /// 可以为全局需要用到堆的地方分配空间。例如 `Box` `Arc` 等 #[global_allocator] static HEAP: LockedHeap = LockedHeap::empty(); /// 初始化操作系统运行时堆空间 pub fn init() { // 告诉分配器使用这一段预留的空间作为堆 unsafe { HEAP.lock().init( HEAP_SPACE.as_ptr() as usize, KERNEL_HEAP_SIZE ) } } /// 空间分配错误的回调，直接 panic 退出 #[alloc_error_handler] fn alloc_error_handler(_: alloc::alloc::Layout) -> ! { panic!(\"alloc error\") } 同时还有一些模块调用等细节代码，这里不再贴出，请参考完成本章后的仓库中的代码。 动态内存分配测试 现在我们来测试一下动态内存分配是否有效，分配一个动态数组： os/src/main.rs /// Rust 的入口函数 /// /// 在 `_start` 为我们进行了一系列准备之后，这是第一个被调用的 Rust 函数 #[no_mangle] pub extern \"C\" fn rust_main() -> ! { // 初始化各种模块 interrupt::init(); memory::init(); // 动态内存分配测试 use alloc::vec::Vec; let mut vec = Vec::new(); for i in 0..100 { vec.push(i); } for i in 0..100 { assert_eq!(i, vec[i]); } println!(\"Dynamic allocating test passed\"); loop{} } 最后，运行一下会看到 Dynamic allocating test passed 类似的输出。有了这个工具之后，后面我们就可以使用一系列诸如 Vec 等基于动态分配实现的库中的结构了。 思考 动态分配的内存地址在哪个范围里？ Click to show 在 .bss 段中，因为我们用来存放动态分配的这段是一个静态的没有初始化的数组，算是内核代码的一部分。 "},"docs/lab-2/guide/part-2.html":{"url":"docs/lab-2/guide/part-2.html","title":"物理内存探测","keywords":"","body":"物理内存探测 物理内存的相关概念 我们知道，物理地址访问的通常是一片 DRAM，我们可以把它看成一个以字节为单位的大数组，通过物理地址找到对应的位置进行读写。但是，物理地址并不仅仅只能访问 DRAM，也可以用来访问其他的外设，因此你也可以认为 DRAM 也算是一种外设，物理地址则是一个对可以存储的介质的一种抽象。 而如果访问其他外设要使用不同的指令（如 x86 单独提供了 in 和 out 等指令来访问不同于内存的 IO 地址空间），会比较麻烦；于是，很多指令集架构（如 RISC-V、ARM 和 MIPS 等）通过 MMIO（Memory Mapped I/O）技术将外设映射到一段物理地址，这样我们访问其他外设就和访问物理内存一样了。 我们先不管那些外设，来看物理内存。 物理内存探测 操作系统怎样知道物理内存所在的那段物理地址呢？在 RISC-V 中，这个一般是由 Bootloader ，即 OpenSBI 来完成的。它来完成对于包括物理内存在内的各外设的扫描，将扫描结果以 DTB（Device Tree Blob）的格式保存在物理内存中的某个地方。随后 OpenSBI 会将其地址保存在 a1 寄存器中，给我们使用。 这个扫描结果描述了所有外设的信息，当中也包括 QEMU 模拟的 RISC-V Virt 计算机中的物理内存。 [info] QEMU 模拟的 RISC-V Virt 计算机中的物理内存 通过查看 QEMU 代码中 hw/riscv/virt.c 的 virt_memmap[] 的定义，可以了解到 QEMU 模拟的 RISC-V Virt 计算机的详细物理内存布局。可以看到，整个物理内存中有不少内存空洞（即含义为 unmapped 的地址空间），也有很多外设特定的地址空间，现在我们看不懂没有关系，后面会慢慢涉及到。目前只需关心最后一块含义为 DRAM 的地址空间，这就是 OS 将要管理的 128 MB 的内存空间。 起始地址 终止地址 含义 0x0 0x100 QEMU VIRT_DEBUG 0x100 0x1000 unmapped 0x1000 0x12000 QEMU MROM 0x12000 0x100000 unmapped 0x100000 0x101000 QEMU VIRT_TEST 0x101000 0x2000000 unmapped 0x2000000 0x2010000 QEMU VIRT_CLINT 0x2010000 0x3000000 unmapped 0x3000000 0x3010000 QEMU VIRT_PCIE_PIO 0x3010000 0xc000000 unmapped 0xc000000 0x10000000 QEMU VIRT_PLIC 0x10000000 0x10000100 QEMU VIRT_UART0 0x10000100 0x10001000 unmapped 0x10001000 0x10002000 QEMU VIRT_VIRTIO 0x10002000 0x20000000 unmapped 0x20000000 0x24000000 QEMU VIRT_FLASH 0x24000000 0x30000000 unmapped 0x30000000 0x40000000 QEMU VIRT_PCIE_ECAM 0x40000000 0x80000000 QEMU VIRT_PCIE_MMIO 0x80000000 0x88000000 DRAM 缺省 128MB，大小可配置 不过为了简单起见，我们并不打算自己去解析这个结果。因为我们知道，QEMU 规定的 DRAM 物理内存的起始物理地址为 0x80000000 。而在 QEMU 中，可以使用 -m 指定 RAM 的大小，默认是 128 MB 。因此，默认的 DRAM 物理内存地址范围就是 [0x80000000, 0x88000000)。 因为后面还会涉及到虚拟地址、物理页和虚拟页面的概念，为了进一步区分而不是简单的只是使用 usize 类型来存储，我们首先建立一个 PhysicalAddress 的类，然后对其实现一系列的 usize 的加、减和输出等等操作，由于这部分实现偏向于 Rust 语法而非 OS，这里不贴出代码，请参考 os/src/memory/address.rs 文件。 然后，我们直接将 DRAM 物理内存结束地址硬编码到内核中，同时因为我们操作系统本身也用了一部分空间，我们也记录下操作系统用到的地址结尾（即 linker script 中的 kernel_end）。 os/src/memory/config.rs lazy_static! { /// 内核代码结束的地址，即可以用来分配的内存起始地址 /// /// 因为 Rust 语言限制，我们只能将其作为一个运行时求值的 static 变量，而不能作为 const pub static ref KERNEL_END_ADDRESS: PhysicalAddress = PhysicalAddress(kernel_end as usize); } extern \"C\" { /// 由 `linker.ld` 指定的内核代码结束位置 /// /// 作为变量存在 [`KERNEL_END_ADDRESS`] fn kernel_end(); } 这里使用了 lazy_static 库，由于 Rust 语言的限制，我们能对编译时 kernel_end 做一个求值然后赋值到 KERNEL_END_ADDRESS 中；所以，lazy_static! 宏帮助我们在第一次使用 lazy_static! 宏包裹的变量时自动完成这些求值工作。 最后，我们在各级文件中加入模块调用，并在 os/src/main.rs 尝试输出。 os/src/main.rs /// Rust 的入口函数 /// /// 在 `_start` 为我们进行了一系列准备之后，这是第一个被调用的 Rust 函数 #[no_mangle] pub extern \"C\" fn rust_main() -> ! { // 初始化各种模块 interrupt::init(); memory::init(); // 注意这里的 KERNEL_END_ADDRESS 为 ref 类型，需要加 * println!(\"{}\", *memory::config::KERNEL_END_ADDRESS); loop{} } 最后运行，可以看到成功显示了我们内核使用的结尾地址 PhysicalAddress(0x8020b220)；注意到这里，你的输出可能因为实现上的细节并不完全一样。 "},"docs/lab-2/guide/part-3.html":{"url":"docs/lab-2/guide/part-3.html","title":"物理内存管理","keywords":"","body":"物理内存管理 物理页 通常，我们在分配物理内存时并不是以字节为单位，而是以一物理页(Frame)，即连续的 4 KB 字节为单位分配。我们希望用物理页号（Physical Page Number，PPN）来代表一物理页，实际上代表物理地址范围在 [PPN×4KB,(PPN+1)×4KB)[\\text{PPN}\\times 4\\text{KB},(\\text{PPN}+1)\\times 4\\text{KB})[PPN×4KB,(PPN+1)×4KB) 的一物理页。 不难看出，物理页号与物理页形成一一映射。为了能够使用物理页号这种表达方式，每个物理页的开头地址必须是 4 KB 的倍数。但这也给了我们一个方便：对于一个物理地址，其除以 4096（或者说右移 12 位）的商即为这个物理地址所在的物理页号。 同样的，我们还是用一个新的结构来封装一下物理页，一是为了和其他类型地址作区分；二是我们可以同时实现一些页帧和地址相互转换的功能。为了后面的方便，我们也把虚拟地址和虚拟页（概念还没有涉及，后面的指导会进一步讲解）一并实现出来，这部分代码请参考 os/src/memory/address.rs。 同时，我们也需要在 os/src/memory/config.rs 中加入相关的设置： os/src/memory/config.rs /// 页 / 帧大小，必须是 2^n pub const PAGE_SIZE: usize = 4096; /// 可以访问的内存区域起始地址 pub const MEMORY_START_ADDRESS: PhysicalAddress = PhysicalAddress(0x8000_0000); /// 可以访问的内存区域结束地址 pub const MEMORY_END_ADDRESS: PhysicalAddress = PhysicalAddress(0x8800_0000); /// 可用的首个物理页号 pub const BEGIN_PPN: PhysicalPageNumber = PhysicalPageNumber::ceil(MEMORY_START_ADDRESS); /// 可用的最后物理页号 + 1 pub const END_PPN: PhysicalPageNumber = PhysicalPageNumber::floor(MEMORY_END_ADDRESS); 分配和回收 为了方便管理所有的物理页，我们需要实现一个分配器可以进行分配和回收的操作，我们使用类似链表的 Vec 来做这件事情，首先先封装一下帧的相关概念。 os/src/memory/frame.rs //! 物理帧的类 use crate::memory::{ address::*, frame::allocator::FRAME_ALLOCATOR, }; /// 分配出的物理帧 /// /// # `Tracker` 是什么？ /// 太长不看 /// > 可以理解为 [`Box`](alloc::boxed::Box)，而区别在于，其空间不是分配在堆上， /// > 而是直接在内存中划一片（一个物理帧）。 /// /// 在我们实现操作系统的过程中，会经常遇到『指定一块内存区域作为某种用处』的情况。 /// 此时，我们说这块内存可以用，但是因为它不在堆栈上，Rust 编译器并不知道它是什么，所以 /// 我们需要 unsafe 地将其转换为 `&'static mut T` 的形式（`'static` 一般可以省略）。 /// /// 但是，比如我们用一块内存来作为页表，而当这个页表我们不再需要的时候，就应当释放空间。 /// 我们其实更需要一个像『创建一个有生命期的对象』一样的模式来使用这块内存。因此， /// 我们不妨用 `Tracker` 类型来封装这样一个 `&'static mut` 引用。 /// /// 使用 `Tracker` 其实就很像使用一个 smart pointer。如果需要引用计数， /// 就在外面再套一层 [`Arc`](alloc::sync::Arc) 就好 pub struct FrameTracker(pub(super) PhysicalAddress); impl FrameTracker { /// 帧的物理地址 pub fn address(&self) -> PhysicalAddress { self.0 } /// 帧的物理页号 pub fn page_number(&self) -> PhysicalPageNumber { PhysicalPageNumber::from(self.0) } } /// 帧在释放时会放回 [`frame_allocator`] 的空闲链表中 impl Drop for FrameTracker { fn drop(&mut self) { FRAME_ALLOCATOR.lock().dealloc(self); } } 这里，我们实现了 FrameTracker 这个结构，而区分于实际在内存中的 4KB 大小的 \"Frame\"，我们设计的初衷是分配器分配给我们 FrameTracker 作为一个帧的标识，而随着\b\b不再需要这个物理帧，我们需要回收，我们利用 Rust 的 drop 机制在析构的时候自动实现回收。 最后给出我们实现分配的算法： os/src/memory/frame/allocator.rs //! 使用链表管理帧 //! //! 返回的 [`FrameTracker`] 类型代表一个帧，它在被 drop 时会自动将空间补回分配器中。 //! //! # 为何 [`FrameAllocator`] 只有一个 usize 大小？ //! 这是一个只有在开发操作系统时可以完成的操作：随意访问地址和读写内存。 //! 我们实现的是内存按帧分配的流程，此时我们就可以使用那些还未被分配的帧来记录数据。 //! //! 因此 [`FrameAllocator`] 记录一个指针指向某一个空闲的帧， //! 而每个空闲的帧指向再下一个空闲的帧，直到最后一个指向 0 即可。 //! 注意所有地址使用的是虚拟地址（使用线性映射）。 //! //! 而为了方便初始化，我们再在帧中记录『连续空闲帧数』，那么最初只需要初始化一个帧即可。 use super::frame::*; use crate::memory::{address::*, config::*}; use alloc::{vec, vec::Vec}; use lazy_static::*; use spin::Mutex; lazy_static! { /// 帧分配器 pub static ref FRAME_ALLOCATOR: Mutex = Mutex::new(FrameAllocator::new()); } /// 基于链表的帧分配 / 回收 pub struct FrameAllocator { /// 记录空闲帧的列表，每一项表示地址、从该地址开始连续多少帧空闲 free_frame_list: Vec, } impl FrameAllocator { /// 创建对象，其中 \\[[`BEGIN_VPN`], [`END_VPN`]) 区间内的帧在其空闲列表中 pub fn new() -> Self { // 定位到第一个可用的物理帧 let first_frame_ppn = PhysicalPageNumber::ceil(*KERNEL_END_ADDRESS); let first_frame_address = PhysicalAddress::from(first_frame_ppn); FrameAllocator { free_frame_list: vec![(first_frame_address, END_PPN - first_frame_ppn)], } } /// 取列表末尾元素来分配帧 /// /// - 如果末尾元素 `size > 1`，则相应修改 `size` 而保留元素 /// - 如果没有剩余则返回 `Err` pub fn alloc(&mut self) -> Result { if let Some((address, page_count)) = self.free_frame_list.pop() { // 如果有元素，将要分配该地址对应的帧 if page_count > 1 { // 如果有连续的多个帧空余，则只取出一个，放回剩余部分 self.free_frame_list .push((address + PAGE_SIZE, page_count - 1)); } Ok(FrameTracker(address)) } else { // 链表已空，返回 `Err` Err(\"no available frame to allocate\") } } /// 将被释放的帧添加到空闲列表的尾部 /// /// 这个函数会在 [`FrameTracker`] 被 drop 时自动调用，不应在其他地方调用 pub(super) fn dealloc(&mut self, frame: &FrameTracker) { self.free_frame_list.push((frame.address(), 1)); } } 这个分配器会把连续的物理页放在一起，每次申请的时候直接把最后一个拿出来分配过去，回收的时候直接把回收回来的帧 push 在末尾。 我们注意到，我们使用了 lazy_static! 和 Mutex 来包装分配器。需要注意到，对于 static mut 类型的修改操作是 unsafe 的。我们之后会提到线程的概念，对于静态数据，所有的线程都能访问。当一个线程正在访问这段数据的时候，如果另一个线程也来访问，就可能会产生冲突，并带来难以预测的结果。 所以我们的方法是使用 spin::Mutex 给这段数据加一把锁，一个线程试图通过 lock() 打开锁来获取内部数据的可变引用，如果钥匙被别的线程所占用，那么这个线程就会一直卡在这里；直到那个占用了钥匙的线程对内部数据的访问结束，锁被释放，将钥匙交还出来，被卡住的那个线程拿到了钥匙，就可打开锁获取内部引用，访问内部数据。 这里使用的是 spin::Mutex，我们需要在 os/Cargo.toml 中添加依赖。幸运的是，它也无需任何操作系统支持（即支持 no_std），我们可以放心使用。 最后，在把新写的模块加载进来，并在 main 函数中进行简单的测试： os/src/main.rs /// Rust 的入口函数 /// /// 在 `_start` 为我们进行了一系列准备之后，这是第一个被调用的 Rust 函数 #[no_mangle] pub extern \"C\" fn rust_main() -> ! { // 初始化各种模块 interrupt::init(); memory::init(); // 物理页分配 for _ in 0..2 { let frame_0 = match memory::frame::FRAME_ALLOCATOR.lock().alloc() { Result::Ok(frame_tracker) => frame_tracker, Result::Err(err) => panic!(\"{}\", err) }; let frame_1 = match memory::frame::FRAME_ALLOCATOR.lock().alloc() { Result::Ok(frame_tracker) => frame_tracker, Result::Err(err) => panic!(\"{}\", err) }; println!(\"{} and {}\", frame_0.address(), frame_1.address()); } loop{} } 可以看到类似这样的输出： 运行输出 PhysicalAddress(0x80a13000) and PhysicalAddress(0x80a14000) PhysicalAddress(0x80a13000) and PhysicalAddress(0x80a14000) 我们可以看到 frame_0 和 frame_1 会被自动析构然后回收，第二次又分配同样的地址。 思考 运行下面的代码： os/src/main.rs /// Rust 的入口函数 /// /// 在 `_start` 为我们进行了一系列准备之后，这是第一个被调用的 Rust 函数 #[no_mangle] pub extern \"C\" fn rust_main() -> ! { // 初始化各种模块 interrupt::init(); memory::init(); // 物理页分配 match memory::frame::FRAME_ALLOCATOR.lock().alloc() { Result::Ok(frame_tracker) => frame_tracker, Result::Err(err) => panic!(\"{}\", err) }; loop{} } 思考，和上面的代码有何不同，我们的设计是否存在一些语法上的设计缺陷？ Click to show 这里的 frame_tracker 变量会在 match 语法里面析构。但是析构的时候，外层的 lock() 函数还没有释放锁，这样写会导致死锁。 "},"docs/lab-3/guide/summary.html":{"url":"docs/lab-3/guide/summary.html","title":"小结","keywords":"","body":"小结 回顾本章，我们理清了虚拟地址和物理地址的概念和关系；并利用页表完成虚拟地址到物理地址的映射；最后实现了内核空间段的重映射。 如果说本章和前一个章节是对空间的划分和管理，那么在下一个小节中，我们将实现对时间的划分和管理，也就是线程。 "},"docs/lab-3/guide/intro.html":{"url":"docs/lab-3/guide/intro.html","title":"摘要","keywords":"","body":"实验指导三 实验概要 这一章的实验指导中，你将会学到： 虚拟地址和物理地址的概念和关系 利用页表完成虚拟地址到物理地址的映射 实现内核的重映射 实验说明 实验指导的部分只包含如何一步步构建我们的目标，并不是练习题。如果你没有兴趣，你不需要完整跟着整个指导去动手做这件事情。但是也许你需要完整的阅读，这将对构建完整的操作系统概念和做练习题有很大帮助。 我们也提供了本章结束后完整的代码实现，你的练习题只需要基于我们给出的版本上增量实现即可。 "},"docs/lab-3/guide/part-1.html":{"url":"docs/lab-3/guide/part-1.html","title":"从虚拟地址到物理地址","keywords":"","body":"从虚拟内存到物理内存 虚拟地址和物理地址 到目前为止，我们简易的操作系统还只是一个内核在执行，还没有多任务的概念。在现代的操作系统中，为了让其他的程序能方便的运行在操作系统上，需要完成的一个很重要的抽象是「每个程序看到的地址空间是一样的」，这将会减少了上层程序的大量麻烦，否则程序本身要维护自己需要的物理内存，这也会导致极大程度的不安全。 这个执行上看到的地址空间，就是虚拟内存。而访问虚拟内存的地址就是虚拟地址（Virtual Address），与之对应的是物理地址（Physical Address）。这样的设计会导致上层的应用程序可能会访问同一个值相等的虚拟地址，所以操作系统需要做的就是替这些程序维护这个虚拟地址到物理地址的映射。甚者，为了统一和连贯，内核自己本身访问内存也将会通过虚拟地址。 我们可以说这个映射的维护是操作系统在做，但是大量频繁的访存不可能全部通过调用操作系统的接口来获取真实的物理地址。所以，这里硬件也会参与，帮我们快速查询操作系统维护的映射，而这个机制就是页表。 如上图所示，这里的图表示了非教学版 rCore 的虚拟地址和物理地址的映射关系。可以看到内核的数据放在了一段高虚拟地址空间，然后会映射到 0x80200000 开始的一段低物理地址空间；而所有的用户程序，将通过操作系统维护的页表映射到不同的物理空间。 Sv39 页表的设计和接口会有很多种，这里我们选择 RISC-V 本身硬件支持的 Sv39 格式作为页表的实现。 在 Sv39 中，定义物理地址有 56 位，而虚拟地址有 64 位。虽然虚拟地址有 64 位，只有低 39 位有效。不过这不是说高 25 位可以随意取值，规定 63-39 位的值必须等于第 38 位的值，否则会认为该虚拟地址不合法，在访问时会产生异常。 Sv39 同样是基于页的，在物理内存那一节曾经提到物理页（Frame）与物理页号（PPN，Physical Page Number）。在这里物理页号为 44 位，每个物理页大小为 4KB。同理，我们对于虚拟内存定义虚拟页（Page）以及虚拟页号（VPN, Virtual Page Number) 。在这里虚拟页号为 27 位，每个虚拟页大小也为 4KB。物理地址和虚拟地址的最后 12 位都表示页内偏移，即表示该地址在所在物理页（虚拟页）上的什么位置。 虚拟地址到物理地址的映射以页为单位，也就是说把虚拟地址所在的虚拟页映射到一个物理页，然后再在这个物理页上根据页内偏移找到物理地址，从而完成映射。我们要实现虚拟页到物理页的映射，由于虚拟页与虚拟页号一一对应，物理页帧与物理页号一一对应，本质上我们要实现虚拟页号到物理页号的映射，而这就是页表所做的事情。 页表项 一个页表项（PTE，Page Table Entry）是用来描述一个虚拟页号如何映射到物理页号的。如果一个虚拟页号通过某种手段找到了一个页表项，并通过读取上面的物理页号完成映射，我们称这个虚拟页号通过该页表项完成映射的。 我们可以看到 Sv39 里面的一个页表项大小为 64 位（即 8 字节）。其中第 53-10 共 44 位为一个物理页号，表示这个虚拟页号映射到的物理页号。后面的第 9-0 位则描述页的相关状态信息。 V 表示这个页表项是否合法。如果为 0 表示不合法，此时页表项其他位的值都会被忽略。 R,W,X 分别表示是否可读（Readable）、可写（Writable）和可执行（Executable）。 以 W 这一位为例，如果为零表示不可写，那么如果一条 store 的指令，它通过这个页表项完成了虚拟页号到物理页号的映射，找到了物理地址。但是仍然会报出异常，是因为这个页表项规定如果物理地址是通过它映射得到的，执行的行为和页表描述的状态并不一致。 同时，根据 R,W,X 取值的不同，我们还有一些特别表示和约定： 也就是说，如果 R,W,X 均为 0，文档上说这表示这个页表项指向下一级页表，我们先暂时记住就好。 U 为 1 表示用户态可以通过该页表项进行映射。事实上用户态也只能够通过 U 为 1 的页表项进行虚实地址映射。 然而，我们所处在的 S 态也并不是理所当然的可以通过这些 U 为 1 的页表项进行映射。我们需要将 S 态的状态寄存器 sstatus 上的 SUM 位手动设置为 1 才可以做到这一点。否则通过 U 为 1 的页表项进行映射也会报出异常。 A 表示 Accessed，如果为 1 则表示自从上次 A 被清零后，有虚拟地址通过这个页表项进行读写。 D 表示 Dirty，如果为 1 表示自从上次 D 被清零后，有虚拟地址通过这个页表项进行写入。 RSW 两位留给 S 态的程序来进行拓展功能实现。 多级页表 一个虚拟页号要通过某种手段找到页表项，那么要怎么才能找到呢？ 想一种最为简单粗暴的方法，在物理内存中开一个大数组作为页表，把所有虚拟页号对应的页表项都存下来。在找的时候根据虚拟页号来索引页表项。即，假设大数组开头的物理地址为 a，虚拟页号为 VPN\\text{VPN}VPN，则该虚拟页号对应的页表项的物理地址为 a+VPN×8a+\\text{VPN}\\times8a+VPN×8（每个页表项 8 字节）。 但是这样会花掉我们大量的内存空间。我们目前只有可怜的 128MB 内存，即使我们有足够的内存也不应该这样去浪费。这是由于有很多虚拟地址我们根本没有用到，因此他们对应的虚拟页号不需要映射，我们开了很多无用的内存。 事实上，在 Sv39 中我们采用三级页表，即将 27 位的虚拟页号分为三个等长的部分，第 26-18 位为三级索引 VPN2\\text{VPN}_2VPN​2​​，第 17-9 位为二级索引 VPN1\\text{VPN}_1VPN​1​​，第 8-0 位为一级索引 VPN0\\text{VPN}_0VPN​0​​。 我们也将页表分为三级页表，二级页表，一级页表。每个页表都用 9 位索引的，因此有 29=5122^{9}=5122​9​​=512 个页表项，而每个页表项都是 8 字节，因此每个页表大小都为 512×8=4KB512\\times 8=4\\text{KB}512×8=4KB。正好是一个物理页的大小。我们可以把一个页表放到一个物理页中，并用一个物理页号来描述它。事实上，三级页表的每个页表项中的物理页号描述一个二级页表；二级页表的每个页表项中的物理页号描述一个一级页表；一级页表中的页表项则和我们刚才提到的页表项一样，物理页号描述一个要映射到的物理页。 具体来说，假设我们有虚拟地址 (VPN2,VPN1,VPN0,offset)(\\text{VPN}_2, \\text{VPN}_1, \\text{VPN}_0, \\text{offset})(VPN​2​​,VPN​1​​,VPN​0​​,offset)： 我们首先会记录装载「当前所用的三级页表的物理页」的页号到 satp 寄存器中； 把 VPN2\\text{VPN}_2VPN​2​​ 作为偏移在三级页表的物理页中找到第二级页表的物理页号； 把 VPN1\\text{VPN}_1VPN​1​​ 作为偏移在二级页表的物理页中找到第一级页表的物理页号； 把 VPN0\\text{VPN}_0VPN​0​​ 作为偏移在一级页表的物理页中找到要访问位置的物理页号； 物理页号对应的物理页基址加上 offset\\text{offset}offset 就是虚拟地址对应的物理地址。 上述流程也可以用下图表示： 我们通过这种复杂的手段，终于从虚拟页号找到了一级页表项，从而得出了物理页号。刚才我们提到若页表项满足 R,W,X 都为 0，表明这个页表项指向下一级页表。在这里三级和二级页表项的 R,W,X 为 0 应该成立，因为它们指向了下一级页表。 然而三级和二级页表项不一定要指向下一级页表。我们知道每个一级页表项控制一个虚拟页号，即控制 4KB 虚拟内存；每个二级页表项则控制 9 位虚拟页号，总计控制 4KB×29=2MB4\\text{KB}\\times 2^9=2\\text{MB}4KB×2​9​​=2MB 虚拟内存；每个三级页表项控制 18 位虚拟页号，总计控制 2MB×29=1GB2\\text{MB}\\times 2^9=1\\text{GB}2MB×2​9​​=1GB 虚拟内存。我们可以将二级页表项的 R,W,X 设置为不是全 0 的，那么它将与一级页表项类似，只不过可以映射一个 2MB 的大页（Huge Page）。同理，也可以将三级页表项看作一个叶子，来映射一个 1GB 的大页。 页表基址 页表的基址（起始地址）一般会保存在一个特殊的寄存器中。在 RISC-V 中，这个特殊的寄存器就是页表寄存器 satp。 我们使用寄存器 satp 来控制 CPU 进行页表映射。 MODE 控制 CPU 使用哪种页表实现，我们只需将 MODE 设置为 8 即表示 CPU 使用 Sv39 。 ASID 表示地址空间标识符，这里还没有涉及到进程的概念，我们不需要管这个地方。 PPN 存的是三级页表所在的物理页号。这样，给定一个虚拟页号，CPU 就可以从三级页表开始一步步的将其映射到一个物理页号。 于是，OS 可以在内存中为不同的应用分别建立不同虚实映射的页表，并通过修改寄存器 satp 的值指向不同的页表，从而可以修改 CPU 虚实地址映射关系及内存保护的行为。 快表（TLB） 我们知道，物理内存的访问速度要比 CPU 的运行速度慢很多。如果我们按照页表机制循规蹈矩的一步步走，将一个虚拟地址转化为物理地址需要访问 3 次物理内存，得到物理地址后还需要再访问一次物理内存，才能完成访存。这无疑很大程度上降低了效率。 事实上，实践表明虚拟地址的访问具有时间局部性和空间局部性。因此，在 CPU 内部，我们使用快表（TLB, Translation Lookaside Buffer）来作为虚拟页号到物理页号的映射的缓存。这部分知识在计算机组成原理课程中有所体现，当我们要做一个映射时，会有很大可能这个映射在近期被完成过，所以我们可以先到 TLB 里面去查一下，如果有的话我们就可以直接完成映射，而不用访问那么多次内存了。 但是，我们如果修改了 satp 寄存器，说明我们切换到了一个与先前映射方式完全不同的页表。此时快表里面存储的映射已经失效了，这种情况下我们要使用 sfence.vma 指令刷新整个 TLB。 同样，我们手动修改一个页表项之后，也修改了映射，但 TLB 并不会自动刷新，我们也需要使用 sfence.vma 指令刷新 TLB。如果不加参数的，sfence.vma 会刷新整个 TLB。你可以在后面加上一个虚拟地址，这样 sfence.vma 只会刷新这个虚拟地址的映射。 "},"docs/lab-3/guide/part-2.html":{"url":"docs/lab-3/guide/part-2.html","title":"修改内核","keywords":"","body":"修改内核 之前的内核实现并未使能页表机制，实际上内核是直接在物理地址空间上运行的。这样虽然比较简单，但是为了后续能够支持多个用户进程能够在内核中并发运行，满足隔离等性质，我们要先运用学过的页表知识，把内核的运行环境从物理地址空间转移到虚拟地址空间，为之后的功能打好铺垫。 更具体的，我们现在想将内核代码放在虚拟地址空间中以 0xffffffff80200000 开头的一段高地址空间中。这意味我们原来放在 0x80200000 的全部内核结构被平移到了 0xffffffff80200000 的地址上，这意味着我们把虚拟地址减去偏移量 0xffffffff00000000 就得到了原来的物理地址。当然，这种线性平移并不是唯一的映射方式，但是至少现在，内核的全部数据所在的虚拟空间和物理空间是这样的线性映射。 首先，和上一章类似，我们先对虚拟地址和虚拟页号这两个类进行了封装，同时也支持了一些诸如 VirtualAddress::from(Physical) 的转换 trait（即一些加减偏移量等操作），这部分实现更偏向于 Rust 语法，这里不再赘述实现方法，想去了解实现时可以参考 os/src/memory/address.rs。 后面，我们把原来的 linker script 和之前在物理内存管理上的一些参数修改一下。 os/src/linker/linker.ld /* Linker Script 语法可以参见：http://www.scoberlin.de/content/media/http/informatik/gcc_docs/ld_3.html */ /* 目标架构 */ OUTPUT_ARCH(riscv) /* 执行入口 */ ENTRY(_start) /* 数据存放起始地址 */ BASE_ADDRESS = 0xffffffff80200000; /* 修改为虚拟地址 */ SECTIONS { /* . 表示当前地址（location counter） */ . = BASE_ADDRESS; /* start 符号表示全部的开始位置 */ kernel_start = .; /* 加入对齐 */ . = ALIGN(4K); text_start = .; /* .text 字段 */ .text : { /* 把 entry 函数放在最前面 */ *(.text.entry) /* 要链接的文件的 .text 字段集中放在这里 */ *(.text .text.*) } /* 加入对齐 */ . = ALIGN(4K); rodata_start = .; /* .rodata 字段 */ .rodata : { /* 要链接的文件的 .rodata 字段集中放在这里 */ *(.rodata .rodata.*) } /* 加入对齐 */ . = ALIGN(4K); data_start = .; /* .data 字段 */ .data : { /* 要链接的文件的 .data 字段集中放在这里 */ *(.data .data.*) } /* 加入对齐 */ . = ALIGN(4K); bss_start = .; /* .bss 字段 */ .bss : { /* 要链接的文件的 .bss 字段集中放在这里 */ *(.bss .bss.*) } /* 加入对齐 */ . = ALIGN(4K); boot_stack_start = .; /* stack 字段 */ .stack : { /* 把 bss.stack 字段所申请的空间放在这里作为启动时的栈空间 */ *(.bss.stack) } /* 结束地址 */ kernel_end = .; } 首先，对于 linker script，我们把放置的基地址修改为了虚拟地址，另外还有一些修改是我们把每个数据段都对齐到了 4KB，一个 4KB 的虚拟页中不会包含两个段，这意味着这个页的属性是可以确定的。举个例子，如果不对齐的话，只读的 .rodata 和 .data 段可能放在一个页中，但是页表中需要写上诸如是否可写的属性，这时候就必须分开才可以标注属性。 对应修改 os/src/memory/config.rs 中的 KERNEL_END_ADDRESS 修改为虚拟地址并加入偏移量： os/src/memory/config.rs lazy_static! { /// 内核代码结束的地址，即可以用来分配的内存起始地址 /// /// 因为 Rust 语言限制，我们只能将其作为一个运行时求值的 static 变量，而不能作为 const pub static ref KERNEL_END_ADDRESS: VirtualAddress = VirtualAddress(kernel_end as usize); } /// 内核使用线性映射的偏移量 pub const KERNEL_MAP_OFFSET: usize = 0xffff_ffff_0000_0000; 之后是 FrameAllocator 确定第一个可用的物理页的位置也需要修改： impl FrameAllocator { /// 创建对象，其中 \\[[`BEGIN_VPN`], [`END_VPN`]) 区间内的帧在其空闲列表中 pub fn new() -> Self { // 定位到第一个可用的物理帧 // 因为 KERNEL_END_ADDRESS 现在成了虚拟地址，所以需要先转换为物理地址再向上取整为第一个可用的物理页 let first_frame_ppn = PhysicalPageNumber::ceil(PhysicalAddress::from(*KERNEL_END_ADDRESS)); let first_frame_address = PhysicalAddress::from(first_frame_ppn); FrameAllocator { free_frame_list: vec![(first_frame_address, END_PPN - first_frame_ppn)], } } ... } 最后一步，我们需要告诉 RISC-V CPU 我们做了这些修改，也就是需要完成一个从物理地址访存模式到虚拟访存模式的转换，同时这也意味着，我们要写一个简单的页表，完成这个线性映射： os/src/asm/entry.asm # 操作系统启动时所需的指令以及字段 # # 我们在 linker.ld 中将程序入口设置为了 _start，因此在这里我们将填充这个标签 # 它将会执行一些必要操作，然后跳转至我们用 rust 编写的入口函数 # # 关于 RISC-V 下的汇编语言，可以参考 https://rv8.io/asm.html # %hi 表示取 [12,32) 位，%lo 表示取 [0,12) 位 .section .text.entry .globl _start # 目前 _start 的功能：将预留的栈空间写入 $sp，然后跳转至 rust_main _start: # 计算 boot_page_table 的物理页号 lui t0, %hi(boot_page_table) li t1, 0xffffffff00000000 sub t0, t0, t1 srli t0, t0, 12 # 8 0x8000_0000 # 0xffff_ffff_8000_0000 -> 0x8000_0000 .quad 0 .quad 0 .quad (0x80000 回顾一下，当 OpenSBI 启动完成之后，我们面对的是一个怎样的局面： 物理内存状态中 OpenSBI 代码放在 [0x80000000,0x80200000) 中，内核代码放在以 0x80200000 开头的一块连续物理内存中； CPU 状态：处于 S Mode ，寄存器 satp 的 MODE 字段被设置为 Bare 模式，即无论取指还是访存我们通过物理地址直接访问物理内存。PC 即为 0x80200000 指向内核的第一条指令； 栈指针寄存器 sp 还没有初始化，还没有指向 bootstacktop； 代码中 bootstacktop 等符号的地址都是虚拟地址（高地址）。 而我们需要做的就是，把 CPU 的访问模式改为 Sv39，这里需要做的就是把一个页表的物理页号和 Sv39 模式写入 satp 寄存器，然后刷新 TLB。 我们先使用一种最简单的页表构造方法，还记得上一节中所讲的大页吗？那时我们提到，将一个三级页表项的标志位 R,W,X 不设为全 0，可以将它变为表示 1GB 的一个大页。 那么，页表里面需要放什么数据呢？第二个 .quad （表中第 510 项，510 的二进制是要索引虚拟地址的 VPN3VPN_3VPN​3​​）显然是从 0xffffffff80000000 到 0x80000000 这样的线性映射，同时 0xcf 表示了 VRWXAD 均为 1 的属性。 观察一下，除了上面这个映射，我们的 boot_page_table 里面为什么还有一个从 0x80000000 到 0x80000000 的映射？ Click to show 这是因为，在跳转到 rust_main 之前（即 jr t0）之前，PC 的值都还是 0x802xxxxx 这样的地址，即使是写入了 satp 寄存器，但是 PC 的地址不会变。为了执行这段中间的尴尬的代码，我们在页表里面也需要加入这段代码的地址的映射。 那为什么跳转之后就没有问题了呢？这是因为 rust_main 这个符号本身是高虚拟地址（这点在 linker script 里面已经体现了）。 为什么我把这个映射删了，代码还是可以运行？因为 QEMU 有指令缓存，实际上这样的删去的写法是错误的。 这个尴尬的映射会对后面产生错误的影响吗？不会，因为在后面，我们将使用 Rust 而不是汇编把新的页表加载到 satp 里面，这个页表只是启动时的一个简单页表，或者我们可以叫它“内核初始映射”，后面我们会加入更细致的映射，把不同的段根据属性放在不同的页面里面。 刷新之后，我们加载完栈底值，就可以跳转到 Rust 编写的函数中了。至此，我可以在主函数中做些简单的输出，我们重新编译（cargo 不会感知 linker script 的变化，可能需要 cargo clean）并运行，正确的结果应该是我们可以看到这些输出，虽然这和上一个章节的结果看上去没什么两样，但是现在内核的运行已经在虚拟地址空间了。 "},"docs/lab-3/guide/part-3.html":{"url":"docs/lab-3/guide/part-3.html","title":"实现页表","keywords":"","body":"实现页表 为了实现 Sv39 页表，我们的思路是把一个分配好的物理页（即会自动销毁的 FrameTracker）拿来把数据填充作为页表，而页表中的每一项是一个 8 字节的页表项。 对于页表项的位级别的操作，我们首先需要加入两个关于位操作的 crate： os/Cargo.toml bitflags = \"1.2.1\" bit_field = \"0.10.0\" 然后，首先了构建了关于虚拟页号获得三级 VPN 的函数： os/src/memory/address.rs impl VirtualPageNumber { /// 得到一、二、三级页号 pub fn levels(self) -> [usize; 3] { [ self.0.get_bits(18..27), self.0.get_bits(9..18), self.0.get_bits(0..9), ] } } 页表项 后面，我们来实现页表项，其实就是对一个 usize（8 字节）的封装： os/src/memory/mapping/page_table_entry.rs //! 页表项 //! //! # RISC-V 64 中的页表项结构 //! 每个页表项长度为 64 位，每个页面大小是 4KB，即每个页面能存下 2^9=512 个页表项。 //! 每一个页表存放 512 个页表项，说明每一级页表使用 9 位来标记 VPN。 //! //! # RISC-V 64 两种页表组织方式：Sv39 和 Sv48 //! 64 位能够表示的空间大小太大了，因此现有的 64 位硬件实际上都不会支持 64 位的地址空间。 //! //! RISC-V 64 现有两种地址长度：39 位和 48 位，其中 Sv39 的虚拟地址就包括三级页表和页内偏移。 //! `3 * 9 + 12 = 39` //! //! 我们使用 Sv39，Sv48 同理，只是它具有四级页表。 use crate::memory::address::*; use bit_field::BitField; use bitflags::*; /// Sv39 结构的页表项 #[derive(Copy, Clone, Default)] pub struct PageTableEntry(usize); impl PageTableEntry { /// 将相应页号和标志写入一个页表项 pub fn new(page_number: PhysicalPageNumber, flags: Flags) -> Self { Self( *0usize .set_bits(..8, flags.bits() as usize) .set_bits(10..54, page_number.into()), ) } /// 获取页号 pub fn page_number(&self) -> PhysicalPageNumber { PhysicalPageNumber::from(self.0.get_bits(10..54)) } /// 获取地址 pub fn address(&self) -> PhysicalAddress { PhysicalAddress::from(self.page_number()) } /// 获取标志位 pub fn flags(&self) -> Flags { unsafe { Flags::from_bits_unchecked(self.0.get_bits(..8) as u8) } } /// 是否为空（可能非空也非 Valid） pub fn is_empty(&self) -> bool { self.0 == 0 } } impl core::fmt::Debug for PageTableEntry { fn fmt(&self, formatter: &mut core::fmt::Formatter) -> core::fmt::Result { formatter .debug_struct(\"PageTableEntry\") .field(\"page_number\", &self.page_number()) .field(\"flags\", &self.flags()) .finish() } } bitflags! { /// 页表项中的 8 个标志位 #[derive(Default)] pub struct Flags: u8 { /// 有效位 const VALID = 1 然而，我们不会把这个巨大的数组在函数之间不停传递，我们这里的思路也同样更多利用 Rust 的特性，所以做法是利用一个 PageTableTracker 的结构对 FrameTracker 封装，但是里面的行为是对 FrameTracker 记录的物理页当成 PageTable 进行操作。同时，这个 PageTableTracker 和 PageTableEntry 也通过一些 Rust 中的自动解引用的特性为后面的实现铺平了道路，比如我们可以直接把 PageTableTracker 当成 PageTable 对待，同时，如果一个 PageTableEntry 指向的是另一个 PageTable 我们可以直接方便的让编译器自动完成这些工作。 os/src/memory/mapping/page_table.rs /// 类似于 [`FrameTracker`]，用于记录某一个内存中页表 /// /// 注意到，『真正的页表』会放在我们分配出来的物理帧当中，而不应放在操作系统的运行栈或堆中。 /// 而 `PageTableTracker` 会保存在某个线程的元数据中（也就是在操作系统的堆上），指向其真正的页表。 /// /// 当 `PageTableTracker` 被 drop 时，会自动 drop `FrameTracker`，进而释放帧。 pub struct PageTableTracker(pub FrameTracker); impl PageTableTracker { /// 将一个分配的帧清零，形成空的页表 pub fn new(frame: FrameTracker) -> Self { let mut page_table = Self(frame); page_table.zero_init(); page_table } /// 获取物理页号 pub fn page_number(&self) -> PhysicalPageNumber { self.0.page_number() } } // PageTableEntry 和 PageTableTracker 都可以 deref 到对应的 PageTable // （使用线性映射来访问相应的物理地址） impl core::ops::Deref for PageTableTracker { type Target = PageTable; fn deref(&self) -> &Self::Target { unsafe { self.0.address().deref_kernel() } } } impl core::ops::DerefMut for PageTableTracker { fn deref_mut(&mut self) -> &mut Self::Target { unsafe { self.0.address().deref_kernel() } } } impl core::ops::Deref for PageTableEntry { type Target = PageTable; fn deref(&self) -> &Self::Target { unsafe { self.address().deref_kernel() } } } impl core::ops::DerefMut for PageTableEntry { fn deref_mut(&mut self) -> &mut Self::Target { unsafe { self.address().deref_kernel() } } } 至此，我们完成了物理页中的页表。后面，我们将把内核中各个段做一个更精细的映射，把之前的那个粗糙的初始映射页表替换掉。 "},"docs/lab-3/guide/part-4.html":{"url":"docs/lab-3/guide/part-4.html","title":"实现内核重映射","keywords":"","body":"实现内核重映射 在上文中，我们虽然构造了一个简单映射使得内核能够运行在虚拟空间上，但是这个映射是比较粗糙的。 我们知道一个程序通常含有下面几段： .text 段：存放代码，需要可读、可执行的，但不可写； .rodata 段：存放只读数据，顾名思义，需要可读，但不可写亦不可执行； .data 段：存放经过初始化的数据，需要可读、可写； .bss 段：存放零初始化的数据，需要可读、可写。 我们看到各个段之间的访问权限是不同的。在现在的映射下，我们甚至可以修改内核 .text 段的代码。因为我们通过一个标志位 W 为 1 的页表项完成映射。 因此，我们考虑对这些段分别进行重映射，使得他们的访问权限被正确设置。 这个需求可以抽象为一大段的内存（可能是很多个虚拟页）通过一个方式映射到很多个物理页上，同时这个内存段将会有一个统一的属性和进一步高层次的管理。 举个例子，在内核的代码段中 .bss 段可能不止会占用一个页面，而是很多页面，我们需要把全部的这些页面以线性的形式映射到一个位置。同时整个这些页面构成的内存段将会有统一的属性交由内核来管理。 下面的结构正在重新设计 ... "},"docs/lab-1/exercise/intro.html":{"url":"docs/lab-1/exercise/intro.html","title":"实验题目一","keywords":"","body":"实验一：异常处理 实验目标 "}}